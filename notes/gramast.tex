% todo: refactor S(G) to gamma


\documentclass[]{article}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript

% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[utf8x]{inputenc}
\else % if luatex or xelatex
  \usepackage{fontspec}
  \ifxetex
    \usepackage{xltxtra,xunicode}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{€}
\fi
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            pdfauthor={},
            pdftitle={},
            colorlinks=true,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

% Treeview
\usepackage{tikz}
\usepackage{tikz-qtree}

% Graphviz
\usepackage{graphvizzz}

% Source Code so found here: http://en.wikibooks.org/wiki/LaTeX/Source_Code_Listings
\usepackage{listings}

% Definitionen
\usepackage{amsthm}

% Algorithmen
\usepackage{algpseudocode}
\usepackage{algorithm}

%todo 
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}

\usepackage{xargs}                      % Use more than one optional parameter in a new commands


\usepackage{url}






% TODO: add improve and question
\newcommandx{\IMPROVE}[2][1=]{\todo[linecolor=none,backgroundcolor=orange!25,bordercolor=none,#1]{\textbf{IMPROVE: }#2}}
\newcommandx{\QUESTION}[2][1=]{\todo[linecolor=none,backgroundcolor=blue!15,bordercolor=none,#1]{\textbf{QUESTION: }#2}}
\newcommandx{\TODO}[2][1=]{\todo[linecolor=none,backgroundcolor=gray!25,bordercolor=none,#1]{\textbf{TODO: }#2}}

\def\signed #1{{\leavevmode\unskip\nobreak\hfil\penalty50\hskip2em
  \hbox{}\nobreak\hfil(#1)%
  \parfillskip=0pt \finalhyphendemerits=0 \endgraf}}

\newsavebox\mybox
\newenvironment{aquote}[1]
  {\savebox\mybox{#1}\begin{quote}}
  {\signed{\usebox\mybox}\end{quote}}


\newtheorem{mydef}{Definition}
\renewcommand*\contentsname{Inhaltsverzeichnis}

\author{Denis Erfurt}
\date{\now}
\title{Ein dezentrales Transitionssystem zur manipulation von Wörtern einer regulären Sprache}


\begin{document}


\tableofcontents


\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      EINLEITUNG
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Abstract}
% überblick
% problembeschreibung, literaturüberblick, related work, 

% Es geht um Akteure, Besitz, Bewertung

% sowie die Bewertung konkurierender Beitragskandidaten, deren Komposition 
% 
% sowie der repräsentation des Inhaltes aus einer Kandidatenmenge. 
% 
% sowie nach den \textbf{Bewertungen} der einzelnen Beiträge durch die Besitzer, deren Komposition als Gesamtergebnis den eigendlichen Inhalt biltet.
% 
% sowie der eigendlichen Form des Inhaltes, welches eine Komposition einzelner Beiträge ist



% Eine besitzbare Einheit kann als eine bestimmte Struktur von Teilen angesehen werden. Die Teile sind wiederum besitzbare Einheiten, deren Besitz vorerst unabhängig vom Besitz des Ganzen ist. Intuitiev sollte der Besitz des Ganzen proportional zu der komposition der Teile sein. Dabei entstehen folgende Fragem:
% - wie berechnet sich die gewichtung eines Teiles.

% Intuitiev sollte der initialle Besitzer eines Inhalts sein Schöpfer sein. Dieser kann sein Besitz bei einer einigung an dritte abgeben, oder der Allgemeinheit überlassen. Bei einem Kollaborativ entstandenem Inhalt, bewerten die Besitzer die Beiträge


% Problem: der Verwaltung( Manipulation ) und der besitzallokation

Im Internet werden zunehmend Inhalte kollaborativ erzeugt. 
Dabei entsteht ein Inhalt durch Beiträge einzelner Akteure, die räumlich und zeitlich getrennt sein können.
Zentral ist dabei die Frage wie der Konsens über einen Inhalt auf eine dezentrale Weise gebildet werden kann.
In dieser Arbeit untersuchen wir den Prozess der verteilten Zusammenarbeit für Inhalte die als Wörter einer regulären Sprache beschrieben werden können. Dafür wird ein Modell mit einer Implementation einer Blockchain-Technologie vorgestellt: Ein öffentliches Transitionssysthem mit dezentral validierter Ausführung. 
Ebenfalls wird eine Grammatik-Erweiterung mit einer Konsens-Funktion für eine beliebige reguläre Grammatik beschrieben. Die Wörter der erweiterten Grammatik beinhalten Informationen über die Besitzallokation der Akteure, alternative Beiträge und deren Bewertung. 
Die Konsens-Funktion überführt unter Berücksichtigung der Bewertungen ein Wort der erweiterten Grammatik in ein Wort der ursprünglichen Grammatik.


% Outline - kurze konkrete zusammenfassung was kommt



% 


\newpage

\section{Einleitung}

Nehmen wir z.B. an, es gäbe eine Webseite, die sich im Besitz von Akteuren befindet. Alle Akteure wollen gerecht, also proportional zu ihrem Besitz, über die Inhalte der Webseite entscheiden können, sowie ihre Entscheidungsgewalt in bestimmten Bereichen an andere vertrauenswürdige Akteure delegieren können. Dieses gilt für die medialen Inhalte, die Programmierung, die Architektur, die Wertflüsse wie ein geteiltes Budget oder eine Einkommensverteilung, sowie nicht automatisierbare Prozesse, wie das Validieren neuer Beiträge. Das eigentliche Ergebnis wird anhand von einer Mehrheit der Besitzer bestimmt.

Wikipedia folgt einem streng hierarchischem Modell, in welchem Vertrauenspersonen die Inhalte der Benutzer filtern. Die Verantwortung liegt bei der Organisation.
Effizienter sind jedoch selbstregulierende Systeme, bei denen die Benutzer die Inhalte der Anderen bewerten. Beispiele wären die auf Voting und Reputation basierenden Plattformen Reddit und StackOverflow.
Ein weiteres Beispiel für die Bewertung von Inhalten ist das Konzept 
Liquid Democracy\cite{Lindenberg2010}, ein Vorschlag der Piratenpartei für eine moderne politische Konsensbildung.
Ein solches Prinzip könnte man auf das Verwalten aller digital geteilter Inhalte verallgemeinern.

Jedoch eignen sich diese Konzepte nur bedingt um damit geteiltes Eigentum wie z.B. eine Webseite zu modellieren, da Abstimmungen auf eine informale Weise vorgenommen werden. Es fehlt einer formalen Syntax, welche die Implikationen einer potentiellen Entscheidung vor der Wahl durch Simulation klarer zeigt, sowie nach der Wahl automatisch ausführt.
Außerdem bedarf es bei den Ansätzen eines zentralisierten Servers, welcher als Angriffspunkt die Glaubwürdigkeit des Prozesses gefährdet, da die Akteure auf die Korrektheit des Servers vertrauen müssen. 

Das 2009 eingeführte Konzept des Bitcoins und der Blockchain\cite{Nakamoto2008} bietet eine Alternative zur zentralen Server-Architektur. Dieses beschreibt ein Protokoll in einem Netzwerk, welches Inhalte aus einem gebildeten Konsens bereitstellt. Es besitzt eine einfache, nicht turing vollständige Skriptsprache, sowie durch ein asymmetrisches Kryptosystem, Rechte und Rollen. Neue Inhalte werden nach einer Validierung ebenfalls in den Konsens aufgenommen. Die einfachste Interpretation von Bitcoin ist die eines Werteträgers, wobei die Beschränkung der Skriptsprache wenig Spielraum für weitere Interpretationen lässt.
Allgemeiner ist das auf dem Bitcoin-Protokoll aufbauende Ethereum\cite{Wood2014} , welches eine turing vollständige Skriptsprache besitzt.
Es entsteht eine Vielzahl von neuen Anwendungsmöglichkeiten: verbindliche, autonome Verträge zwischen mehreren Parteien, dezentrale autonome Organisationen (DAO) oder profitorientierte Kooperationen (DAC), die allesamt Werte- und Informationsflüsse ermöglichen.
Ein Beispiel einer solchen DAO ist das namecoin\footnote{http://namecoin.info/} Konzept, welches als Alternative zur ICANN\footnote{Internet Corporation for Assigned Names and Numbers} Organisation die TLD ".bit" verwaltet und in naher Zukunft die ICANN ablösen könnte.\cite{Corporation2014} Die Regeln unter denen DACs und DAOs funktionieren, wie das Bewilligen einer neuen TLD, werden auf der Ethereum VM programmiert.
Die Einigung der Akteure auf ein Programmstand geschieht noch durch eine zentrale Vertrauensinstanz, z.b. bestimmten Schlüsselpersonen.



\section{Theoretisches}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      VERIFIZIERUNG 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\subsection{Reguläre Grammatiken}
Eine reguläre Grammatik definiert nach Noam Chomsky ist ein vier Tupel 
$G = (N,T,S,P)$ bestehend aus 

\begin{enumerate}
\item $N$ - einer Menge nichtterminaler Symbole 
\item $T$ - einer Menge terminaler Symbole, disjunkt zur nichtterminalen Menge $T\cap N = \emptyset$
\item $S\in N$ - einem Startsymbol
\item $P \subseteq N\times \{\epsilon\}\cup T \cup TN$ - einer Menge von Produktionen
\end{enumerate}

Eine Produktion $(R,r)\in P$ kann auch als $R\rightarrow r$ geschrieben werden.
Sie sagt aus das das das Nichtterminal R in einem Schritt überführt werden kann zum Teilwort r:
\[ \alpha R \rightarrow \alpha r \]. Sind hierfür n Schritte notwendig schreibt man
$R \rightarrow^n r$. Um auszudrücken, dass $r$ generell aus $R$ ableitbar ist, kann man sich der reflexiv-transitiven Hülle der Produktionsregeln bedienen: $R \rightarrow ^* r$.

Die Sprache, die von der regulären Grammatik erzeugt wird ist die Menge aller Wörter, die vom Startsymbol ableitbar sind: 
\[ L(G) := \{w | S \rightarrow^* w \land w\in T^* \} \]
Existiert eine reguläre Grammatik, die eine Sprache erzeugt, so heißt die Sprache ebenfalls regulär.

Die Klasse der regulären Sprachen heißt $REG$.

Ein Beispiel für eine reguläre Grammatik mit der dazugehörigen Sprache ist: 

\begin{center}
 $
\begin{array}{rcl}
  G &=& (N,T,S,P) \\
  N &=& \{ S, A, B, C \} \\
  T &=& \{ a, b, c \} \\
  P &=& \{ \\ 
  &&  S \rightarrow a A,
    S \rightarrow b B,
    S \rightarrow c C,
    S \rightarrow \varepsilon,\\
  &&  A \rightarrow a A,
    A \rightarrow b B,
    A \rightarrow c C,
    A \rightarrow \varepsilon,\\
  &&  B \rightarrow b B,
    B \rightarrow c C,
    B \rightarrow \varepsilon, \\
  &&  C \rightarrow c C,
    C \rightarrow \varepsilon,\\
  &&\}
\end{array}
$ 
\end{center}

\[ L(G) = \{ a^xb^yc^z | x,y,z\in \mathbb{N} \} \] 

\subsection{Kontextfreie Grammatiken}

Kontextfreie Sprachen unterscheiden sich nur in den Produktionsregeln von den regulären. Anders als bei regulären, wird für die rechte Seite einer Produktionsregel keine Einschränkung gemacht: $P \subseteq N\times (N\cup T)^*$

% \subsection*{Greibach-Normalform}
% Da eine reguläre Grammatik ein Spezalfall einer Kontextfreien Grammatik ist und jede Kontextfreie Grammatik in der Greibach-Normalform darstellbar ist ist jede reguläre Grammatik ebenfalls in der Greibach-Normalform darstellbar.
% 
% Warum muss die reguläre Grammatik in der Greibach-Normalform sein?
% Durch die Grammatikerweiterung werden die Regeln der Regulären Grammatik mit Optionsmengen erweitert. Gibt es eine Regel $A->B$, kommt es du einer mehrdeutung der Ableitung da eine Optionsmenge bei $A$ und $B$ erzeugt wird.

\subsection{Trie}

Ein Trie oder Prefixbaum ist eine Baum-Datenstruktur, die es erlaubt eine Menge von Worten über einem Alphabet effizient zu Speichern. Dabei werden gemeinsame Präfixe von wörtern in Knoten zusammengefasst.
Eine Trie verwandte Datenstruktur, die Patricia-Trie reduziert den Speicherverbrauch indem sie alle Knoten mit nur einem Nachfolger zu einem Knoten zusammenfasst.
Alle im Trie und Patricia-Trie gespeicherten Wörter können durch ein Tiefenscan wiederhergestellt werden. \cite{Morrison1968}
Ein Beispiel eines Patricia-Trie für die Menge $\{ aaaaa, aac, aacc, aaccc, aabbb, aabb \}$ ist:

\begin{center}
\Tree [.aa aaa c [.c c cc ] [.b bb b ] ]
\end{center}


\subsection{Transitionsystem}
Ein initialisiertes Transitionssystem ($T$) \cite{Glausch} gibt einen formalismus vor um ein zustandbasiertes System zu beschreiben. Die Beschreibung zerteilt sich in die des Zustandraumes, beschrieben durch eine Menge $M$, die der Dynamik, beschrieben durch eine Übergangsfunktion $\tau: M \rightarrow M$ und einer Anfangszustandsmenge $I\subset M$.
\[ T = (M,I,\tau) \] 


% section  (end)

\subsection{Kryptografie}

\TODO[inline]{ecdsa}
\TODO[inline]{hash}

\subsubsection*{asymetrische Verschlüsselung}
Bei einem asymmetrischem verschlüsselungs verfahren generiert der Benutzer ein schlüsselpaar bestehend aus einem privatem und einem öffentlichem schlüssel. Der öffentliche Schlüssel wird aus dem Privatem erzeugt und wir veröffentlicht. Wir werden im folgenden für den öffentlichen Schlüssel ebenfalls Addresse nennen, die einen Akteur identifiziert. Agiert der Akteur im Netzwert, beweist dieser durch die Signierung der Aktionen, dass dieser tatsächlich im Besitz des Privatem schlüssel ist und beweist dadurch seine Identität.

\subsubsection*{Signierung}

Eine Aktion( oder auch Nachricht (msg) genannt) eines Akteurs kann mit dem privatem schlüssel signiert werden.
\[ signMsg: priv \times msg \rightarrow sign \] 
Mithilfe einer weiteren Funktion kann nun durch die öffentliche Addresse des Akteurs, der nachricht und deren Signatur verifiziert werden, ob die Nachricht auch tatsächlich vom angegebenem Akteur ausgelöst wurde.
\[ verifyMsg: msg \times sign \times addr \rightarrow \{ True, False \} \] 
Dadurch besteht nun eine Aktion eines Akteurs aus der nachricht, seiner Addresse sowie der signatur der nachricht.

\[ (msg, sign, addr) \]

\subsection{Decentralized Autonomous Organization (DAO)}
Eine DAO ist ein relativ neues Konzept, welches durch das populärwerden Technologien wie Bitcoin und Ethereum erstmals aufgetaucht ist. Die Fachwelt ist sich noch über die genaue Definition und die abgrenzung zu verwanten Konzepten größtenteils uneinig. Zwar exestieren Versuche "Decentralized Applications" (DAs,Dapps) wie BitTorrent oder den "Decentralized Autonomous Corporations" (DACs) von dem der DAOs Abzugrenzen, jedoch gibt es hier keine Garantie auf Persistenz der Begriffe sowie ihrer Definitionen, desshalb werden im folgenden die Begriffe DA, Dapp, DAC, DAO synonym verwendet.

Intuitiv kann eine DAO als eine Gesellschaft verstanden werden, die ohne menschliche Einwirkung existiert und agiert. Sie kann ebenfalls als eine erweiterung des Open-Source Konzeptes betrachtet werden. Dabei ist nicht nur der \textbf{Programmcode öffentlich}, sondern auch ihre internen Berechnungen sowie wesentliche Teile ihrer Interkationen. Diese sind durch einen gemeinsamen \textbf{Konsens} von der Erzeugung bis zum aktuellen Zustand determiniert und nachvollziehbar. Dieser Konsens wird auf eine dezentrale Weise gebildet, um zu verhindern, dass eine zentrale Instanz den Konsens manipuliert sowie um Robustheit und Beständigkeit zu sichern.

In ihren Aktionen kann die DAO interne, deterministische Berechnungen anstellen, mit anderen DAOs komunizieren und so auf Services zugreifen oder nicht selbst ausführbare Aufgaben, wie beispielsweise das Erweitern und Verbessern des Programmcodes, an Menschen deligieren. Ihr besitz kann durch Anteile determiniert werden, die unter anderen DAOs oder Menschen aufgeteilt sind. Diese berechtigen beteiligte Akteure zu verschiedenen Aktionen innerhalb ihrer Regeln wie z.B. einen Zugriff auf Dividenden oder anderen Ressourcen der DAO, partizipation bei internen Abstimmungen oder anderen spezifischen Aktionen. 

Ethereum, Bitcoin und Namecoin sind allesamt Beispiele für unterschiedliche DAOs. Ethereum ist dabei gleichzeitig eine Plattform für andere DAOs.
% In der Bitcoin DAO sind die Anteile eines Akteurs ander DAO ebenfalls ihr zweck. Durch die limitierung besitzen sie in Märkten einen Wert sodass die Anteile als Werteträger zu einer dezentralen währung werden.

\TODO[inline]{Kapselung - Teilbereiche - Komponenten}

Im folgenden möchten wir drei Teilberreiche von DAOs näher beleuchten. Als erstes die Funktionsweise des Blockchain Algorithmus, der eigendlichen Neuerung, die zum Entstehen von DAOs führte. Als nächstes dem Teil, der die Interaktionen der DAO steuert. Als letztes der Selbstmanipulation der DAO, also dem Teil, welcher die Manipulation der Regeln der DAO steuert.


\subsubsection*{Dezentraler Konsens - Blockchain}

Bitcoin hat mit der einführung der Blockchain eine elegante und Universelle Lösung für das Problem der Byzantinischen Generäle vorgeschlagen. Das Problem steht repräsentativ in den verteilten Systemen für die Schwierigkeit, einen Konsens zwischen Akteuren herzustellen, wenn einige, für Andere unbestimmte Akteure eigennützig sowie manipulativ agieren. 
Bitcoin hat hier eine statistische Lösung presentiert: Es führt die dezentralität des Konsens auf die natürliche Knapheit einer Ressource zurück. Für Bitcoin ist es die Anzahl der Berechnungen, die ein Akteur in einer bestimmten Zeit machen kann. Ein General versucht dabei ein Mathematisches Rätsel zu lösen, welches statistisch gesehen 10 Minuten dauern müsste, wenn alle beteiligten Generäle an dem Problem arbeiten würden. Hat ein General eine Lösung gefunden, teilt er dieses an alle Ihm bekannten Generäle mit. Eine solche Lösung wird auch als "Block" bezeichnet. Jeder General arbeitet darauf hin mit dieser Lösung weiter und versucht sie zu erweitern, was wieder statistisch 10 Minuten der Kraft aller Generäle kosten müsste. Jeder General arbeitet mit der von ihm zuerst gesehenen längsten kette von Blöcken. Mit der Anzahl der Erweiterungnen konvergiert nun die beteiligung loyaler Generäle am Konsens zur majorität, falls diese tatsächlich in Besitz einer Mehrheit der Begrenzten Rechenressourcen besitzen.
In einem Block befindet sich neben der vorhergehenden Lösung ebenfalls der aktuelle Konsenses solange er auf den vorergehenden aufbaut und valide ist.

Das Lösen eines Rätsels für das Recht einen neuen Block bestimmen zu können, wird als "proof of work" oder kurz POW bezeichnet, da ein General eine Arbeitsleistung beweisen müssen, um den nächsten Block vorschlagen zu dürfen. Bitcoin und viele andere DAOs benutzen partielle hash invertierung als tatsächlichen POW Algorithmus. Dieser baut auf der Eigenschaft einer Hash-Funktion, dass es sehr einfach ist einen Hash einer Nachricht zu berechnen, jedoch sehr schwehr aus einem Hash eine Nachricht zu rekonstruieren, die diesen hash erzeugt. Der eigendliche Block besteht dabei aus einer referenz des vorherigen Blocks $(ref)$ zusammen mit dem neuen Konsens ($kons$) und einer $nonce$, die frei wählbar ist. Zudem existiert durch die vorherigen Blöcke bestimmte Schwierigkeit ($\varepsilon$), so dass die Rechenzeit für den neuen Block bei 10 Minuten bleibt. Akteure, die im Wettbewerb um einen neuen Block stehen (auch "Miner" genannt) müssen nun eine nonce finden so, dass einen Hashwert des Blockes unter der schwierigkeit liegt:
\[ sha256(\ ref\ kons\ nonce\ ) < \varepsilon \] 

POW ist jedoch umstritten, da das verbrauchen von Rechenressourcen nicht ökonomisch und umweltfreundlich ist. Um die Rechenpower des Bitcoinnetzwerkes in Relation zu setzen hatten die Top 500 Weltbesten Supercomputer der Welt im November 2014 gemeinsam eine Rechenleistung von 309 Pflop/s.\footnote{http://www.top500.org/lists/2014/11/ 18.02.2015} Das Bitcoinnetzwerk besitzt derzeit (18.02.2015) eine Rechenleistung von 4172436 Pflop/s.\footnote{http://bitcoinwatch.com/ 18.02.2015}.


Neben POW gibt es jedoch auch andere Mechanismen für die Berechtigung einen Block erstellen zu dürfen. Hier gilt "Proof of Stake" (POS) und seine erweiterung "Deligated Proof of Stake"(DPOS) als interessant. Bei POS beweist ein Akteur, dass ihm ein bestimmter Anteil an der Blockchain zugehörigen DAO gehört. Bei  DPOS kann ein Anteilseigener zusätzlich sein Anteil an einen Miner deligieren und muss nicht selbst an der erstellung eines Blocks teilnehmen. Jedoch sind hier theoretische Attaken möglich (siehe dazu \cite{EthereumBlogPOS} \cite{Vasant2015}), weshalb diese POW noch nicht abgelöst haben. Bitshares \footnote{https://bitshares.org/blog/delegated-proof-of-stake/ 18.02.2015} - ein Bitcoin fork mit einem DPOS oder Peercoin\footnote{http://peercoin.net/ 18.02.2015} ein fork mit reinem POS sind realwirtschaftliche Beispiele für DAOs mit einem Alternativen Konsensmechanismus die zumindest zeigen, dass diese Mechanismen es schaffen ebenfalls in der Praxis zu bestehen.

\TODO[inline]{coins einführen}

Das erstellen von Blocks durch Miner ist zumindest bei Bitcoin ökonomisch motiviert. Die Bitcoin DAO schüttet eine Belohnung an den Miner aus, der einen neuen Block findet. Bei Bitcoin werden derzeit (18.02.2015) 25 Bitcoins ausgeschüttet, was zum derzeitigen Marktpreis (240\$/Btc) einem Wert von 6000\$/Block entspricht.  
Zum Zeitpunt der ersten Blocks exestieren noch keine Coin-Bestände, diese werden von dem ersten Block an an konkurierende Miner für die Blockerstellung ausgeschüttet. Die größe der Belohnung wird mit der Zeit kleiner, bis irgendwann eine Menge von 21 Millionen coins ereicht ist. Eine andere Motivation der Miner ist eine Transaktionsgebühr, die ein Akteur seiner Transaktion anhängt. Diese Gebühr bekommt ein Miner, wenn er diese in seinem Block berücksichtigt.


\subsubsection*{Interaktion}

\subsubsection*{Turing Vollständigkeit}

Das auf dem Bitcoin-Protokoll\cite{Nakamoto2008} aufbauende Ethereum \cite{Wood2014}, beschreibt ein P2P Protokoll zur dezentralen Verifizierung von Turing-Vollständigen Programmausführungen. 
Es stellt einen gebildeten Konsens von Programmen mit aktuellen Zuständen bereit. 
Neue Inhalte wie neue Programme oder neue Interaktionen von Akteuren mit Programmen werden nach einer Veröffentlichung und Validierung der Ausführung durch das Netzwerk mit dem neu berechnetem Zustand in den Konsens aufgenommen.

Agierende Instanzen sind einerseits externe Akteure, die durch ein asymmetrisches Kryptosystem mit anderen Akteuren im Netzwerk interagieren. Andererseits sind Akteure Turing-Vollständige Programme, die vom Netzwerk bereitgestellt werden. Solche Akteure werden auch (smart-)\textbf{contracts} genannt.
Akteure sowie Contracts werden durch ein 20-Byte Adresse identifiziert.

Die Validierungsknoten des Ethereum-Netzwerks finanzieren sich einerseits durch die Neuschöpfung einer internen Währung, sowie durch einen Betrag, der für die Validierung einer Programmausführung von einem Akteur bezahlt wird. Für jeden Berechnungsschritt der Ethereum-VM wird dafür ein kleiner Betrag erhoben. Ist nicht genügend Wert verfügbar, terminiert die Transaktion und wird vom Netzwerk abgelehnt. So wird auch das Halteproblem umgangen.

\begin{aquote}{Ethereum Whitepaper p. 28 \cite{Butterin2014}}
  [...] halting problem: there is no way to tell, in the general case, whether or not a given program will ever halt.
  [...] our solution works by requiring a transaction to set a maximum number of computational steps that it is allowed to take, and if execution takes longer computation is reverted but fees are still paid.
\end{aquote}


Ein Contract besteht aus einem assoziativem Speicher der den Programmcode sowie Daten beinhaltet.

Ein Beispiel für ein Programm ist eine dezentrale Währung, wie sie derzeit vom Bitcoin Protokoll repräsentiert wird (Quelle \cite{Butterin2014}):

% ! Akteure = Programme | Benutzer

\begin{lstlisting}
  from = msg.sender
  to = msg.data[0]
  value = msg.data[1]

  if self.storage[from] >= value:
  self.storage[from] = self.storage[from] - value
  self.storage[to] = self.storage[to] + value
\end{lstlisting}

% NAMECOIN
% if !contract.storage[msg.data[0]]:
%     contract.storage[msg.data[0]] = msg.data[1]
%     return(1)
% else:
%     return(0)

Eine neue interessante Anwendung ist ein \textbf{geteilter} manipulierbar Inhalt, im folgenden Objekt genannt. 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   GETEILTES OBJEKT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{(selbst) Modifikationsschicht einer DAO}
\subsection{Definition}

Ein \textbf{geteiltes digitales Objekt} ist ein Tupel $O_G=(A, K, w, rate, consens)$ bestehend aus:

\begin{enumerate}
\item Eine endliche Menge von Akteuren $A$
\item Eine eindeutige \textbf{Besitzverteilung} von Akteuren zum Objekt
  \[w: A \rightarrow \mathbb{N}\]
\item eine endliche Menge von validen \textbf{Kandidaten} mit mindestes einem Element 
  \[K_G \subseteq L(G) \land |K_G| \geq 1\] 
\item eine Bewertung der Kandidaten durch die Akteure. 
  \[rate: A\times K \rightarrow [0,1]\]
\item einer Konsensfunktion
  \[consens: A\times K\times w \times rate \rightarrow L(G)\] 
\end{enumerate}

Sei $\mathbf{SOBJ_G}$ die Menge aller geteilten Objekte in der Grammatik $G$ sowie 
 $\mathbf{P_G}:= \{ K_G | K_G \subseteq L(G) \}$ die Menge aller möglichen Kandidatenmengen.

\subsection{Erläuterung}


\subsubsection*{Besitzverteilung}

%Aktienmodell

Die Besitzverteilung wird ähnlich dem Aktienmarkt Modelliert. Dabei hat ein geteiltes Objekt eine bestimmte Anzahl an Teilen (geschrieben $|O| \in \mathbb{N}$), die unter den Akteuren aufgeteilt sind. 
\[ |O| := \sum_{a \in A} w(a) \] 

% Besitz = Bestimmung
Der Besitz eines Objekts $O$ wird durch das Recht definiert, auf dieses zugreifen zu können und es Kontrollieren zu können\cite{Waldron2004}. Besitzen mehrere Akteure ein Objekt, so gibt der Anteil am Objekt an, zu welcher Gewichtung jeder einzelne Akteur über das Objekt mitbestimmen kann.

Eine Konsensfunktion entscheidet über die Ausführung der Kontrolle.
% Dabei kann eine Zustimmung von $\frac{1}{2}|O|$ eine Ausführung bedingen. Man spricht von einer \textbf{majorität}. Eine Zustimmung von $\frac{2}{3}|O|$ heißt \textbf{super majorität}.




% Die Funktion $w_O: A \rightarrow \mathbb{N}$ gibt den Anteil von O an, der im Besitz von einem Akteur ist. 

% Gilt $share_O(a) > 0$, so nennt man $a$ auch ein \textbf{Member} von $O$.
% 
% $M_O \subseteq A$ ist die Menge aller Member von $O$.



\subsubsection*{Transaktionen}

Transaktionen sind Manipulationen des Objektes. Sie werden \textbf{immer} von einem Akteur $a$ ausgelöst und besitzen die Form $(a, O')$. $O'$ ist dabei das manipulierte geteilte Objekt. \textbf{Transaktionsbedingungen} entscheiden über die Validität der Transaktion und demnach über ihre Anwendung.

Wir betrachten vorerst nur die Manipulation der Kandidatenmenge $K$ sowie der Kandidatenbewertung $rate$. 

% Eine triviale Transaktionsbedingung ist, dass sich in der Kandidatenmänge nur valide Kandidaten befinden.


\subsubsection*{Konsens}

  \[consens: A\times K\times w \times rate \rightarrow L(G)\] 


Die Konsensfunktion liefert für jedes Objekt ein Wort aus der $L(G)$ Sprache.
Dabei sucht die Funktion nach dem Kandidaten aus der Kandidatenmenge mit der maximalsten Bewertung. Die Bewertung eines Kandidaten ergibt sich dabei durch die Summe der gewichteten Bewertungen der Akteure.

\[ consens (A,K_G,w,rate) := \max_{k\in K_G} ( \sum_{a\in A} w(a) * rate(a,k) ) \] 


% \subsubsection*{Bewertung}

%todo: bewertung kann kontextfrei sein -> an die spracherweiterung binden? 
%todo: für kontextsensitive bewertungen gibt es 1) deligationen und 2) direkte kandidatenbewertungen

\subsubsection*{Qualitätskriterien}

Für die Implementation ist auf folgende Qualitätskriterien zu achten:

\begin{description} 
  \item[\textbf{RESMIN:}]\hfill \\
    Es sind möglichst wenig Ressourcen (Speicher und Rechenleistung) vom Ethereum-Netzwerk notwendig, um Transaktionen zu validieren.
  \item[\textbf{INTMIN:}]\hfill \\
    Eine Akteur soll möglichst wenig Interaktionen benötigen, um auf eine gewünschte, von ihm erreichbare Manipulation zu kommen.
\end{description}

% 
%   * die Kandidatenmenge muss komprimiert werden, damit deren Speicherung möglichst wenig Speicher in anspruch nimmt.
%   * die validierung der manipulation muss eine kleine laufzeit haben.

% 

% es ist einfach für einen Akteur eine Bewertung über viele Kandidaten abzugeben.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     IMPLEMENTATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\TODO[inline]{Metasprache einführen}
\TODO[inline]{Transitionsysthem einführen: problem der codierung}

\section{Anwendung auf reguläre Grammatiken}

\subsection{Optimierung der Kandidatenmenge}
Die reguläre Grammatik wird so zu einer kontextfreien Grammatik erweitert, dass alle Wörter aus der Kandidatenmenge in einem Wort der erweiterten Grammatik codiert werden können. Dieses kann einfach durch eine Trie-Datenstruktur realisiert werden die redundant auftauchende Präfixe der Kandidaten zusammengefasst. Die Serialisierung der Tries ist eben ein Wort, welcher von der gesuchten Grammatikerweiterung dargestellt werden soll. 

Dafür wird an jedem Ableitungsschritt eine Mehrdeutigkeit zugelassen die zu einer \textbf{Optionsmenge} zusammengefasst wird. Die Kandidatenmenge ergibt sich durch die Kombinationen der Präfixe mit den Optionen einer Optionsmenge.

Dazu muss es eine Grammatik-Erweiterung $S: REG\rightarrow CFG$ gefunden werden.
Um zu zeigen, dass es sich bei $S$ um die gesuchte Erweiterung handelt, muss die Existenz der Funktionen $\phi: P(L(G)) \rightarrow L(S(G))$ und $\phi^{-1}: L(S(G)) \rightarrow P(L(G))$ gezeigt werden, für die folgende Bedingungen erfüllt sein müssen:

\begin{align}
  \phi\circ\phi^{-1} &= id_{P(K_G)} \\
  |\phi(K_G)| &\lesssim \sum_{k\in K_G} |k|
\end{align}


Die Bedingung (1) kann auch abgeschwächt werden zu $K_G\subseteq \phi\circ\phi^{-1}(K_G)$. Dieses würde bedeuten, dass Kandidaten nicht verloren gehen, jedoch hinzukommen können, solange diese valide Kandidaten bilden.

In Bedingung (2) werden Edge-Cases ausgeschlossen, die nur bei kleinen diversen Lösungen auftauchen können. (z.B.: $\{a\ b\}$)


% \subsection{Qualitätskritärien}
% 
% \begin{enumerate}
%   \item die wörter der Sprache $L(SCFG)$ sind möglichst klein
%   \item es ist einfach Optionen zu Bewerten: Die Anzahl der transitionen ist möglichst klein, um auf ein gewünschtes Bewertungsprofil zu kommen.
%     
%     Sei $a\in A$ ein Akteur, sei $X_i\subseteq P\times [0,1]$ die derzeitige Bewertung der Programme von $a$ und sei $X_j\subseteq P\times [0,1]$ die gewünschte Bewertung. Sei $t$ eine von $a$ gültige Transformation, so dass $X_k \rightarrow_{t} X_{k+1}$ und sei T die Menge der von a gültigen Transformationen. Die Bewertung ist einfach, wenn für $X_i \rightarrow_{ T }^n X_j$ n möglichst minimal ist.
% \end{enumerate}

\subsubsection*{Grammatik-Erweiterung S1}


Sei $G = (N,T,S,P)$ eine reguläre Grammatik in der Greibach-Normalform.


$
\begin{array}{rl}
  S_1(G) :=& (N', T', S, P') \\
  N' :=& N \cup \{ O_R\ |\ (R\rightarrow r)\in P\land O_R \notin N\}\\
  T' :=& T \cup \{[ , ]\ |\ [,]\notin T \}\\
  P' :=& P
  \cup P_{Options} 
  \\
  P_{Options} :=& \{R \rightarrow [O_R], O_R \rightarrow r O_R, O_R \rightarrow \varepsilon \ \vert\ R\rightarrow r\in P
  \land r\in (N\cup T)^*\} \\
\end{array}
$

\subsubsection*{Definition $\phi$}



Sei $S(\alpha,K)$ die Funktion, die den Größten gemeinsamen Präfix aller Kandidaten liefert, die den Präfix $\alpha$ enthalten:

\[ E(\alpha, K) : \exists w\in K: w=\alpha\beta \] 

\[ 
  A(\alpha, K): 
    \exists ! \beta \forall x, y\in K\exists t, t' \in T\cup\{\varepsilon\}: \\
    ( x = \alpha \beta t \gamma_1 \land y = \alpha \beta t' \gamma_2 ) \Rightarrow 
    ( t = \gamma_1 = \varepsilon \lor t' = \gamma_2 = \varepsilon \lor t \neq t' )
\] 

\[
  S( \alpha, K ) := 
  \begin{cases}
    \beta & E(\alpha,K) \land A(\alpha,K) \\
    \varepsilon & otherwise
  \end{cases}
\] 
    
% 1. Was ist wenn K leer ist, 
%   s ist epsilon
% was ist wenn K ein elementig ist, 
%   
% was ist wenn kein element den präfix alpha besitzt
% was ist wenn alpha epsilon ist

Sei $U$ die Funktion, die einem Präfix und einer Kandidatenmenge die Wörter zuordnet, die nach diesem Präfix kommen.
\[ U( \alpha, K ) := \{t S(\alpha t, K) |\ \alpha t \beta \in K \land ( t\in (T \lor t=\beta=\varepsilon )) \} \] 

Sei $Q$ die Funktion, die bei der übergabe einer Wortmenge K und einem präfix $\alpha$ eine Menge aller Wörter zurückliefert, die den Präfix $\alpha$ enthalten.

\[ Q(\alpha, K):= \{x |x\in K\land x=\alpha\beta\text{ mit } \beta \in T^*\} \] 

\[ 
  O(\alpha, \beta, M):=
  \begin{cases}
    \beta & | |M| = 1 \\
    \beta [E(\alpha, U( \alpha, M ), M)] &|otherwise
    % [\bigcirc_{\beta \in U( \alpha, M )} (\beta O(\alpha \beta, Q(\alpha\beta, M))'\ ')] 
  \end{cases}
\] 

\[ 
  E( \alpha, B, M ) := 
  \begin{cases}
    \varepsilon & |B =  \{ \varepsilon \}\\
    \beta & |B =  \{ \beta \}\\
    (O(\alpha, \beta, Q(\alpha\beta, M))'\ ' E(\alpha, B\setminus \{\beta\}, M))\text{ mit }\beta\in B &| otherwise
  \end{cases}
\] 

Dann ist $\phi := O( \varepsilon, S(\varepsilon, K), K)$ die gesuchte Funktion.


\subsubsection*{Definition $\phi^{-1}$}

\[ 
  \phi^{-1}(w) := 
  \begin{cases}
    U(\alpha, \beta) &| \alpha [ \beta ] = w \\
    \{ w \}   &| otherwise
  \end{cases}
\] 

\[ 
  U( \alpha, w ):= 
  \begin{cases}
    \phi^{-1}(\alpha x) \cup U(\alpha,s) &| w = x '\ ' s \\
    \phi^{-1}(\alpha w) &|otherwise
  \end{cases}
\] 

\subsubsection*{zeige $\phi\circ\phi^{-1} = id_{P(K_G)}$}

Sei $T(K_G)$ die Trie Datenstruktur, die die Kandidatenmenge $K_G$ codiert.
Wir wissen, dass es eine Funktion $\phi(K_G)=T(K_G)$ exestiert, sowie $\phi\circ\phi^{-1} = id_{P(L(G))}$. Zu finden ist demnach eine Funktion die ein Tire codiert zum Wort der Metasprache sowie wieder encodiert zur Tire.
  
\TODO[inline]{zeige $\phi\circ\phi^{-1} = id_{P(K_G)}$}

\subsubsection*{zeige $|\phi(K_G)| \lesssim \sum_{k\in K_G}$}

\TODO[inline]{zeige $|\phi(K_G)| \lesssim \sum_{k\in K_G}$}


\subsection{Optimierung der Kandidatenbewertung}

\subsubsection*{Komprimierung}
Die Idee hinter der Komprimierung ist, die Bewertung der Kandidaten an Optionen zu binden. Wenn ein Akteur eine Option in einer Optionsmenge bewertet, so gibt er seine Stimme der Option im Kontext zu dem bisherigen Präfix des Wortes. Somit werden alle Kandidaten, die sich mit dem Präfix und der Option erzeugen lassen von der Stimme beeinflusst. Diese wird als ein Attribut der Ableitung vererbt\cite{Knuth1968} und jeweils von einer Bewertung einer tieferen Ebene ersetzt. Eine wichtige Bedingung ist, dass jede mögliche Bewertungsverteilung in der Optimierung codierbar ist. Dieses ist leicht zu zeigen, da die Bewertung aller Blätter des Ableitungsbaumes ebenfalls die Bewertung der Kandidaten repräsentiert.

% \subsubsection*{zeige: eine beliebige Kandidatenbewertung ist in S2 codierbar.}
% \TODO[inline]{zeige: eine beliebige Kandidatenbewertung ist in S2 codierbar.}

% Sei \phi_w die funktion, die jedem kandidaten einen wert zuordnet.
% idee hinter dem beweis ist, das die letzte geschachtelte option und somit die Bewertung nirgendwo mehr auftaucht. wenn diese -1 <= w <= 1 sein kann, die bewertung des pfades vorher ebenfalls 0 <= p <= 1 ist, so ist  p_i = min( max( p + w, 0 ), 1) so, dass 0 <= p_i <= 1 


\subsubsection*{Delegationen}

Für die Minimierung der Interaktion wird transitives Abstimmen zugelassen. Akteure können nicht nur für die Option selbst abstimmen, sondern auch ihre Stimme für Optionsmengen an andere Akteure so delegieren, dass diese im Kontext der delegierten Option für den Akteur mitbestimmen.

Durch die lineare Struktur der Worte und somit auch der Delegationsmengen ergibt sich nicht nur eine Menge der Delegationen für eine Optionsmenge, sondern auch eine totale Ordnung der Delegationen, womit bei konkurierenden Delegationen immer die Delegation höherer Ordnung genommen wird. 

\TODO[inline]{konkurierende Delegationen}

% Meine erste Idee war es. Abstimmungen an Optionen zu binden. Dadurch würde sich ein Präferenzprofiel für einen Akteur ergeben, bei dem der Akteur die Kandidaten am besten Bewertet, bei denen die meisten Optionen enthalten sind, für die er sich ausgesprochen hat. Ein solchens vorgehen ist zwar bei kontextfreien inhalten sinvoll, da jedoch durch Programme ein kontextsensitiver Inhalt dargestellt ist, muss ein beliebiges Präferenzprofiel über der Kanddatenmenge möglich sein, dieses ist jedoch nicht möglich, wenn die Abstimmungen an Optionen gebungen werdnen.


\subsubsection*{Besitzverteilung}

Schließlich wird die Besitzverteilung ebenfalls als Teil der erweiterten Sprache angesehen. Dies erlaubt nun den Konsens des Objektes als Interpretation eines Wortes der $L(S(G))$ Sprache zu definieren. Transformationen werden als valide Manipulationen eines Wortes definiert. Transformationsbedingungen geben dabei Anforderungen an die Ableitungsstruktur des bisherigen Wortes sowie an das Manipulierte Wort. Dieses determiniert die Validität einer Transaktion.

% Akteure werden durch einen 20 byte hex String codiert.







\subsubsection*{Grammatik-Erweiterung S}


\textbf{number} stellt eine ganzzahlige Nummer dar. \textbf{float}
stellt eine Fließkommazahl dar, so dass $0\leq float \leq 1$. \textbf{hash} identifiziert einen Akteur, hier ist $hash$ ein 20 Bytes HEX-String. \\

\begin{align}
  S(G) :=& (N', T', S', P') \\
  N' :=& N \cup \{ O_R | (R\rightarrow r)\in P\land O_R \notin N\}\cup\{D, A, S'\}\\
  T' :=& T \cup \{[ , ], \oplus, number, float, hash\ |\ [,],\oplus \notin T \}\\
  P' :=& P
  \cup P_{Options} 
  \cup P_{Start} 
  \cup P_{Delegations} 
  \cup P_{Voting} 
  \cup P_{Acteurs}
  \\
  P_{Acteurs} :=& \{A\rightarrow[hash\ number]A,A\rightarrow \varepsilon\} \\
  P_{Options} :=& \{R \rightarrow [O_R][D], O_R \rightarrow r\oplus [V] O_R, O_R \rightarrow \varepsilon \ \nonumber\\
  &\vert\ R\rightarrow r\in P \land r\in (N\cup T)^*\} \\
  P_{Start} :=& \{S'\rightarrow [A][O_S][D]\} \\
  P_{Delegations} :=& \{D\rightarrow [hash\ hash]D,D\rightarrow [hash\ hash]\} \\
  P_{Voting} :=& \{V\rightarrow [hash\ float]V, V \rightarrow \varepsilon\}
\end{align}


\subsubsection*{zeige S(G) ist eindeutig}
\TODO[inline]{zeige S(G) ist eindeutig}


\subsection{Konsens}

\TODO[inline]{definiere $consens: L(S(G)) \rightarrow L(G)$}

% Die Idee hier ist, dass die transitive Hülle der Delegationen als
% Attribut während der Ableitung vererbt(inherited) wird. Die Votemenge
% wird hingegen als Attribut synthetisiert. Die Delegationen zusammen mit
% den Stimmen quantifizieren jede Option aus einer Optionsmenge und wählen
% eine Konsens-Option.

% Sei $\alpha,\beta$ und $o$ Wörter über dem Terminalalphabet. 
% 
% \[ \alpha, \beta, o \in T^* \] 
% 
% Sei $W_\alpha^\beta\subseteq K_G$ die Menge der Wörter, die $\alpha$ als Prefix und $\beta$ als Suffix besitzen. 
% 
% \[W_\alpha^\beta:=\{w|w=\alpha o\beta\land w\in K_G\}\]
% 
% 
% Falls $|W_\alpha^\beta|>1$ sowie $|\alpha| + |\beta| > 0$ gilt, folgt aus der Eindeutigkeit der Ableitung von $G$, dass es eine Regel $(R\rightarrow r)\in P$ exestieren muss, so dass $S \rightarrow^*_P \alpha R \beta$, sowie $\forall \alpha o \beta \in W_\alpha^\beta: R \rightarrow_P^* o$.
% 
% Sei $O_\alpha^\beta := \{o\in T^* | \alpha o \beta \in W_\alpha^\beta \}$, so reicht es $\alpha, \beta$ sowie jedes Element von $O_\alpha^\beta$ anzugeben, um die Menge zu beschreiben. 

% \subsubsection*{Algorithmus}

% Sei $O^R:=\{w| R \rightarrow^* w \}$. Wir definieren $O_r \subseteq O^R$ als die Teilmenge der Wörter von $O^R$, die durch die Regelausführung $(R\rightarrow r)\in P$ gebildet wurden.  \\
% 
% 
% \begin{algorithm}
%   
% \caption{$\phi: P(K_G) \rightarrow L(S(G))$}\label{euclid}
% \begin{algorithmic}[1]
% \Function{$\phi$}{$K_G$}
% \State\Return \Call{combine}{$K_G, S$}
% \EndFunction
% \\
% 
% \Function{combine}{$O^R, R$} 
% \If {$|O^R| = 1$}
%     \Return $o\in O^R$
% \Else
%   \State $W \gets \{\}$
%   \For{ $(R\rightarrow r)\in P$ }
%     \State $O_{r} \subseteq O^R$
%     \State $W\gets W\cup$ \Call{parse}{$O_r, r$}
%   \EndFor
%   \If {$|W|=1$}
%   \State\Return $w\in W$
%   \Else
%   \State\Return $[w_0 w_1 ... w_{|W|}]$
%   \EndIf
% \EndIf
% \EndFunction  
% \\
% 
% \Function{parse}{$O_r, r=s_0s_1...s_n$} 
%   \State $o\gets \epsilon$
%   \For{ $i\gets 0...n$ }
%     \If{$s_i\in T$}
%       \State$o \gets o \circ s_i$
%     \Else
%       \State$o \gets o \circ $ \Call{combine}{$O^s_i, s$}
%     \EndIf
%   \EndFor
% \EndFunction
% 
% \end{algorithmic}
% \end{algorithm}

% In Zeile (27) steht $O^s$ für die Menge der teilweörter von O, die an der Stelle von s, durch die regel R erzeugt werden.

% \TODO[inline]{Definition und Algorithmus für $O^s_i$ angeben.}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    MANIPULATION 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Transitionssystem}

% so dass alle Transaktionen des Objektes als Transaktionen eines contextfreien Wortes angesehen werden können. Die Transaktionsbedingungen können als Struktur des Wortes aufgefasst werden.
% Die Idee hinter der manipulation ist des es sich bei den Wörter um eine Persistente Datenstruktur handelt. Demnach können Optionen nur hinzu kommen, jedoch nicht gelöscht werden. Jeder Akteur kann Delegationen und Stimmen abgeben sowie
% die eigenen löschen, hat jedoch keine Macht über die Stimmen und
% Delegationen der Anderen.

Die Manipulation wird durch ein \textbf{initialisiertes Transitionssysthem $T=(M,I,\tau)$} beschrieben nach \cite{Glausch}.

$M$ ist die Zustandsmenge. $I\subseteq M$ ist die Anfangszustandsmenge und $\tau$ ist die Transformation von M sowie $\tau: M \rightarrow M$. Wir machen weiter die Einschränkung $|I|=1$.


% \subsection{Qualitätskritärien}
% 
% \begin{enumerate}
%   \item operationen wie $vote, delegate, addOption$ sind effizient in bezug auf Laufzeit und Speicherverbrauch.
%   \item Die Verifikation der Transaktion durch das Netzwerk soll möglichst effizient sein.
% \end{enumerate}

\subsubsection*{Wortteil}

Sei $G=(S,N,T,P)$ eine Grammatik und $w\in L(G)$, dann definieren wir ein Wortteil: 
\[ 
w_{i..j} := 
\begin{cases}
  (t_k)_{i\leq k \leq j}\text{ mit }t_k\in T &|\ i\leq j \\
  \varepsilon &|\ i>j
\end{cases}
\] 


\subsubsection*{Ablauf}
Eine Folge $(s_n)_{n\in\mathbb{N}}$ mit $s_n\in M$ ist ein Ablauf von T, wenn gilt:

\[ s_0 \in I \] 
\[ s_{i+1} = \tau(s_i) \] 

\subsubsection*{Zustände}

Sei $G = (N,T,S,P)$ eine rechtsreguläre Grammatik sowie
$S(G)=(N',T',S',P')$ die dazugehörige erweiterte Grammatik.

Ein Zustand ist eine Struktur der Form $(U, w) \in M$

U ist die Trägermenge der Struktur und besteht aus den Wörtern der Sprache $L(S(G))$:
\[U := L(S(G))\]

% $consens$ ist die für $L(S(G))$ definierte konsens Funktion:
$w\in U$ ist das derzeitige Wort

\subsubsection*{Aktualisierung}
Sei $A$ die Menge der Akteure, $L(S(G))$ eine Sprache zur gegebenen Grammatik $G$. Dann ist das Tupel $\delta = (a,w')$ mit $a\in A,\ w'\in L(S(G))$ eine Aktualisierung. Sei $\Delta \subseteq A\times L(S(G))$ die Menge aller aktueller Aktualisierungen.

Akteure können jederzeit die Aktualisierungsmenge erweitern: 
\[ \Delta' := \Delta \cup \{(a,w')\} \] 


\subsubsection*{Transformation}
Sei $\Delta \neq \emptyset$ 

\[
  \tau( w ) = 
  \begin{cases}
    w'  & \exists (a,w') \in \Delta \land \beta(a,w,w') = true \\
    w   & andernfalls 
  \end{cases}
\] 

Nach jeder Transformation wird die Aktualisierungsmenge ebenfalls aktualisiert, in dem die für die Transformation verwendete Aktualisierung entfernt wird. Wurde keine Aktualisierung verwendet, so sind alle Aktualisierungen invalide:

\[ 
  \Delta' = 
  \begin{cases}
    \Delta\setminus \{ (a, w' )\} & (a,w')\text{ wurde in der Transformation verwendet} \\
    \{\} & andernfalls
  \end{cases}
\] 


\subsubsection*{Validierung der Aktualisierung}
Um die Validität einer Transformation zu verifizieren, wird das derzeitige Wort $w$ zusammen mit dem auslösenden Akteur $a$ sowie seinem vorgeschlagenem Wort $w'$ betrachtet. Die Transformation ist valide, falls eines der folgenden Fälle zutrifft.
Es gilt also: $\beta(a,w,w') = true$ genau dann wenn:

% \subsubsection*{ACID Eigenschaft der Transaktionen}
% 
% Atomicity - Daten-Operationen entweder ganz oder gar nicht ausgeführt wird
% 
% Consistency - Sequenz von Daten-Operationen nach Beendigung einen konsistenten Datenzustand hinterlässt
% 
% Isolation - nebenläufig in Ausführung befindliche Daten-Operationen gegenseitig beeinflussen
% 
% Durability - erfolgreichen Abschluss einer Transaktion garantiert dauerhaft in der Datenbank gespeichert sind




\subsubsection*{Optionsmengen}
Eine Optionsmenge kann an jeder Position im Wort erzeugt oder erweitert werden, solange die erzeugte Kandidatenmenge durch $\phi^{-1}(w')$ valide bleibt, sowie die Bewertungen der Kandidaten $\phi^{-1}(w)$ nicht verändert werden. Die neu hinzukommenden Optionen dürfen keine Delegationen oder Stimmen enthalten, sowie noch nicht in der bisherigen Optionsmenge enthalten sein.

\subsubsection*{Erzeugen einer Optionsmenge}

Sei $S(G) = (T', N', S', P')$ eine erweiterte Grammatik. Sei weiter $O,S'\in N'$ sowie $v,o_1,o_2 \in T'^*$ und $0\leq i\leq j\leq n$ mit $i,j,k,n \in \mathbb{N}$

\begin{eqnarray}
  w &=& w_{0..n} \\
  w_{i..j} &=& \alpha o_1 \oplus [v] \\
  S' &\rightarrow^*& w_{0 .. (i-1)}\ O\ w_{(j+1) .. n}\\
  O &\rightarrow^*& w_{i..j} \\
  R &\rightarrow^*& o_1 \\
  R &\rightarrow^*& o_2 \\
  w' &=& w_{0..i-1}\ \alpha [o_1\oplus [v] o_2\oplus []][]\ w_{j+1 .. n}
\end{eqnarray}


Für $w$ hat $O$ folgende Struktur:
\begin{center}
\Tree [.O $\alpha$ [.R $o_1$ ] $\oplus$ $\lbrack$ [.V v ] $\rbrack$ [.O ... ] ]
\end{center}


Für $w'$ besitzt O folgende Struktur:
\begin{center}
\Tree [.O $\alpha$ [.R $\lbrack$ [.O $o_1$ $\oplus$ $\lbrack$ [.V v ]  $\rbrack$ [.O $o_2$ $\oplus$ $\lbrack$ [.V $\epsilon$ ] $\rbrack$ ] ] $\rbrack$ $\lbrack$ [.D $\epsilon$ ] $\rbrack$ ] $\oplus$ $\lbrack$ $\rbrack$ [.O ... ] ]
\end{center}

Dabei muss $o_2$ frei von Delegationen und Stimmen sein, sowie $o_2$ muss relativ zu $o_1$ neu sein.


\subsubsection*{Erweitern einer Optionsmenge}
 
Sei $o,d,r \in T'^*$ sowie $R,O_R \in N'$

\begin{eqnarray}
  w &=& w_{0..n} \\
  w_{i..j} &=& \alpha[o][d] \\
  R   & \rightarrow ^*& w_{i..j}\\
  O_R & \rightarrow_P^*& o\\
  O_R & \rightarrow ^* & r\\
  w' & = & w_{0..(i-1)}\ \alpha[o r\oplus []][d]\ w_{(j+1)..n} 
\end{eqnarray}

$r$ muss dabei Delegations- und Stimmfrei sein sowie neu:
\[ \phi^{-1}(w) \cap \phi^{-1}(w_{0..i-1}\ \alpha[r\oplus []][d]\ w_{j+1..n}) = \emptyset \] 


\subsubsection*{Hinzufügen einer Stimme}

Sei $w_{i..j} = r\oplus [v]$

Dann ist $w' = w_{0 .. i-1}\ r \oplus [v[h n]]\ w_{j+1 .. n}$ mit $0\leq n\leq 1$ eine valide Substitution.

\subsubsection*{Löschen einer Stimme}

Sei $a\in A, v,v'\in T'^*$

\begin{eqnarray}
  w &=& w_{0..n} \\
  w_{i..j}&=& r\oplus [v [an] v'] \\
  w' &=& w_{0..(i-1)} r\oplus [vv'] w_{(j+1)..n}
\end{eqnarray}


\subsubsection*{Hinzufügen einer Delegation}
Da die Reihenfolge der Delegationen wichtig ist, für die Auflösung konkurierender Delegationen, daher ist das Hinzufügen einer Delegation an jeder Stelle in einer Delegationsmenge möglich.

Sei $o,d_i \in T'^*$ sowie $a'\in A$ und $a'\neq a$

\begin{eqnarray}
  w &=& w_{0..n} \\
  w_{i..j} &=& [o][d_1 .. d_n] \\
  &&k,n\in \mathbb{N} \land k\leq n \\
  d_k &=& [hash1_k\ hash2_k] \\ 
  w' &=& w_{0 .. (i-1)}\ [o][d_1 .. d_{k-1} [a\ a'] d_k .. d_n ]\ w_{(j+1) .. n}
\end{eqnarray}

\subsubsection*{Löschen einer Delegation}

Sei $o,d_i \in T'^*$ sowie $a'\in A$ und $a'\neq a$

\begin{eqnarray}
  w &=& w_{0..n} \\
  d_k &=& [a\ a'] \\
  w_{i..j} &=& [o][d_1 .. d_{k} .. d_n ] \\
  w' &=& w_{0 .. (i-1)}\ [o][d_1 .. d_{k-1} d_{k+1} .. d_n ]\ w_{(j+1) .. n}
\end{eqnarray}

\subsection{Delegationsprogrammierung}
Akteure können ihre Stimme nicht nur an externe Akteure delegieren, sondern auch an Contracts, welche in einer autonomen Weise abstimmen und so die Interessen der Akteure automatisch verfolgen. 

\subsubsection*{Beispiele}

Sei $G=(T,N,P,S)$ eine rechtsreguläre Grammatik mit:
\[ T:=\{ a, b, c \}, N:=\{S\}, P:= \{S\rightarrow aS\ |\ bS\ |\ cS\ |\ \varepsilon \} \] 

Ein Delegationsprogramm kann mit dem Interesse entwickelt werden, nur für Kandidaten der kontextsensitiven Sprache $L = \{ a^nb^nc^n\ |\ n\in N\}$ zu stimmen so, dass falls die Mehrheit der Akteure ihm seine Stimme delegieren, der Konsens-Kandidat ebenfalls ein Element der Sprache $L$ sein wird. Auf diese weise lassen sich von den Akteuren komplexe Programme erstellen um die Kandidatenmenge agil und autonom zu bewerten.

\section{ Beispiele }

\subsection*{ abc - Grammatik }
\subsection*{ reddit - Grammatik }
\subsection*{ memGenerator - Grammatik }



% section  (end)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      IMPLEMENTATIONSPLAN
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Umfang der Arbeit}

\subsection*{Konzeptuell}
\begin{itemize}
  \item Die Punkte unter Aufgaben (TODO's) werden ausformuliert.
  \item Dieses Papier wird überarbeitet und strukturiert. Es wird mit anschaulichen Beispielen, Erklärungen, Beweisen,  Quellen sowie Verweisen grundlegender Konzepte ergänzt. Solche Konzepte sind: 
    \begin{itemize}
      \item reguläre/ kontextfreie Grammatik, Normalformen, Ableitungen, Eindeutigkeit
      \item Algebraisches-Transitionssystem
      \item $\Sigma$-Strukturen/-Signaturen
      \item Turing-Vollständigkeit
      \item asymmetrische Verschlüsselung
    \end{itemize}
  \item Die Punkte unter Aussicht werden diskutiert, jedoch weder implementiert, noch im Umfang der Anwendung auf die regulären Grammatiken konzipiert.
\end{itemize}


\subsection*{Implementation}
\begin{itemize}
  \item Eine Zentralisierte Version der $L(S(G))$-Sprache sowie des Transitionssystem wird implementiert.
  \begin{itemize}
    \item JISON\footnote{http://jison.org/}, eine javascript Portierung des Bison\footnote{http://www.gnu.org/software/bison/}/Flex\footnote{http://flex.sourceforge.net/} LALR(1) Parser Generators wird so erweitert, dass bei Eingabe einer beliebigen regulären Grammatik $G$ im bison Format\footnote{http://dinosaur.compilertools.net/bison/bison\_6.html} dieser einen Parser erzeugt welcher Wörter aus der $L(S(G))$ Sprache als Eingabe bekommt und ein öffentliches Transitionssystem erzeugt.
    \item Ein Initialisierungs-Script, welches aus einem Wort der $L(G)$ Sprache und einer Besitzverteilung gegeben als $\{(a,n)| a\in\ 20byteHexString \land n\in \mathbb{N} \}$ ein valides initiales Wort in der $L(S(G))$ Sprache erzeugt.
    \item Akteure können durch eine Webseite in die Transaktionshistorie einsehen, sowie das Wort valide manipulieren.
    \item Eine Client-seitige asymmetrische Verschlüsselung validiert die Transaktionen der Akteure.
    \item Die Konsens-Funktion wird ebenfalls Implementiert und erzeugt zu jedem Stand einen öffentlich verfügbaren Konsens-Kandidaten.
  \end{itemize}
  \item Einige anschauliche Beispiele regulärer Sprachen mit beispielhaften Delegationsprogrammen werden implementiert und demonstriert.
\end{itemize}




\subsection*{Todos}

\listoftodos[Aufgaben]



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%       Aussicht
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Zusammenfassung und Ausblick}
% outline nochmal
% Auswertung - bewertende zusammenfassung

\subsection*{Aussicht}

\subsubsection*{Anwendung auf kontextfreie Grammatiken}

% Die validität einer Sprache ist jedoch meist nicht nur aus der kontextfreien syntax zu schließen. So werden namensresolutionen und typisierung beim compilieren in späteren schritten auf eine kontext sensitive weise überprüft. Dies
% Syntax von Programmiersprachen sind nicht kontextfrei, sondern Kontextsensitiv \cite{Otto}

% Validitätskritärien: Objekt hängt von keiner Grammatik ab, sondern von einer Mänge von Validitätskritärien von denen die Grammatik eine sein kann. Die validitätskritärien schränken den Raum der Kandidaten automatisch ein. Die ausgewählten Kandidaten der Kandidatenmenge sind somit alle valide. Ihre bewertung sind präferrenzen der akteure.
% \[ K \subseteq VK \subseteq \bigcap_{v\in V} v \] 

\subsubsection*{Dezentralisierung}

\subsubsection*{Anonymisierung}

\subsubsection*{Manipulation der Besitzverteilung}
\subsubsection*{Manipulation der Grammatik}


% \begin{itemize}
%   \item änderungen der Grammatik berücksichtigen
% \end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      QUELLEN
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage
\section{Quellen}


\bibliography{library}

\bibliographystyle{alpha}

\end{document}
