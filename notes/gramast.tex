\documentclass[]{article}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript

% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[utf8x]{inputenc}
\else % if luatex or xelatex
  \usepackage{fontspec}
  \ifxetex
    \usepackage{xltxtra,xunicode}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{€}
\fi
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            pdfauthor={},
            pdftitle={},
            colorlinks=true,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

% Treeview
\usepackage{tikz}
\usepackage{tikz-qtree}

% Graphviz
\usepackage{graphvizzz}

% Source Code so found here: http://en.wikibooks.org/wiki/LaTeX/Source_Code_Listings
\usepackage{listings}

% Definitionen
\usepackage{amsthm}

% Algorithmen
\usepackage{algpseudocode}
\usepackage{algorithm}

%todo 
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}

\usepackage{xargs}                      % Use more than one optional parameter in a new commands

\newcommandx{\TODO}[2][1=]{\todo[linecolor=none,backgroundcolor=gray!25,bordercolor=none,#1]{\textbf{TODO: }#2}}

\def\signed #1{{\leavevmode\unskip\nobreak\hfil\penalty50\hskip2em
  \hbox{}\nobreak\hfil(#1)%
  \parfillskip=0pt \finalhyphendemerits=0 \endgraf}}

\newsavebox\mybox
\newenvironment{aquote}[1]
  {\savebox\mybox{#1}\begin{quote}}
  {\signed{\usebox\mybox}\end{quote}}


\newtheorem{mydef}{Definition}


\author{}
\date{}

\begin{document}


\tableofcontents


\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      EINLEITUNG
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Einleitung}

% Es geht um Akteure, Besitz, Bewertung
Im Internet werden zunehmend Inhalte kollaborativ erzeugt. 
Dabei entsteht ein Inhalt durch Beiträge einzelner \textbf{Akteure}.
Zentral ist die Frage nach dem \textbf{Besitz} des Inhaltes sowie die \textbf{Bewertung} der einzelnen Beiträge durch die Besitzer und damit ihren Anteil am \textbf{Gesamtergebnis}. 


% Problem: der Verwaltung( Manipulation ) und der besitzallokation
In dieser Arbeit wird dieses Problem für Inhalte einer regulären Sprache untersucht. Dafür wird ein dezentral validiertes Transitionssysthem vorgestellt welches die Manipulation eines Ihnaltes durch Akteure steuert. Dafür wird eine Grammatikerweiterung vorgestellt, dessen Wörter Informationen über die Besitzallokation der Akteure, alternative Inhalte sowie deren Bewertung durch die Akteure beinhalten. Der Konsens der Akteure über den Inhalt wird als Interpretation des Wortes berechnet und ist durch die verfügbaren Informationen determiniert. 

\newpage




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      VERIFIZIERUNG 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Dezentrale Verifizierung}

Das auf dem Bitcoin-Protokoll\cite{Nakamoto2008} aufbauende Ethereum \cite{Wood2014}, beschreibt ein P2P Protokoll zur dezentralen Verifizierung von turing-vollständigen Programmausführungen. 
Es stellt einen gebildeten Konsens von Programmen mit Aktuellen Zuständen bereit. 
Neue Inhalte wie neue Programme oder neue Interaktionen von Akteuren mit Programmen werden nach einer veröffentlichung und Validierung der Ausführung durch das Netzwerk mit dem neu berechnetem Zustand in den Konsens aufgenommen.

Akteure sind einerseits externe Akteure, die durch ein asymmetrisches Kryptosystem mit anderen Akteuren im Netzwerk interagieren. Andererseits sind Akteure turing vollständige Programme, die vom Netzwerk bereitgestellt werden. Solche Akteure werden auch (smart-)\textbf{contracts} genannt.
Akteure sowie contracts werden durch ein 20-byte Adresse identifiziert.

Die Validierungsknoten des Ethereum-Netzwerks finanzieren sich einerseits durch die Neuschöpfung einer internen Währung, sowie durch einen Betrag, der für die Validierung einer Programmausführung von einem Akteur bezahlt wird. Für jeden Berrechnungsschritt der Ethereum-VM wird dafür ein kleiner Betrag erhoben. Ist nicht genügend Wert verfügbar, terminiert die Transaktion und wird vom Netzwerk abgelehnt. So wird auch das Halteproblem umgangen.

\begin{aquote}{Ethereum Whitepaper p. 28 \cite{Butterin2014}}
  [...] halting problem: there is no way to tell, in the general case, whether or not a given program will ever halt.
  [...] our solution works by requiring a transaction to set a maximum number of computational steps that it is allowed to take, and if execution takes longer computation is reverted but fees are still paid.
\end{aquote}

Ein Beispiel für ein Programm währe eine dezentrale Währung, wie sie derzeit vom Bitcoin Protokoll repräsentiert wird (Quelle \cite{Butterin2014}):

% ! Akteure = Programme | Benutzer

\begin{lstlisting}
  from = msg.sender
  to = msg.data[0]
  value = msg.data[1]

  if self.storage[from] >= value:
  self.storage[from] = self.storage[from] - value
  self.storage[to] = self.storage[to] + value
\end{lstlisting}


Ein Contract besteht aus einem assoziativem Speicher der den Programmcode sowie Daten beinhaltet.

Eine neue interessante Anwending ist ein \textbf{geteilter} manipulierbar Inhalt, im folgenden Objekt genannt. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   GETEILTES OBJEKT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Digital Geteiltes Objekt}
\subsection{Definition}

Ein \textbf{geteiltes digitales Objekt} ist ein Tupel $O_G=(A, K, w, rate, consens)$ bestehend aus:

\begin{enumerate}
\item Eine endliche Menge von Akteuren $A$
\item Eine eindeutige \textbf{Besitzverteilung} von Akteuren zum Objekt
  \[w: A \rightarrow \mathbb{N}\]
\item eine endliche Menge von validen \textbf{Kandidaten} mit mindestes einem Element 
  \[K_G \subseteq L(G) \land |K_G| \geq 1\] 
\item eine Bewertung der Kandidaten durch die Akteure. 
  \[rate: A\times K \rightarrow [0,1]\]
\item einer Konsensfunktion
  \[consens: A\times K\times w \times rate \rightarrow L(G)\] 
\end{enumerate}

Sei $\mathbf{SOBJ_G}$ die Menge aller geteilten Objekte in der Grammatik $G$ sowie 
 $\mathbf{P(K_G)}:= \{ K_G | K_G \subseteq L(G) \}$ die Menge aller möglichen Kandidatenmengen.

\subsection {Erläuterung}


\subsubsection*{Besitzverteilung}

%Aktienmodell

Die Besitzverteilung wird änlich dem Aktienmarkt Modelliert. Dabei hat ein geteiltes Objekt eine bestimmte Anzahl an Teilen (geschrieben $|O| \in \mathbb{N}$), die unter den Akteuren aufgeteilt sind. 
\[ |O| := \sum_{a \in A} w(a) \] 

% Besitz = Bestimmung
Der Besitz eines Objekts $O$ wird durch das Recht definiert, auf dieses zugreifen zu können und es Kontrollieren zu können\cite{Waldron2004}. Besitzen mehrere Akteure ein Objekt, so gibt der Anteil am Objekt an, zu welcher gewichtung jeder einzelne Akteur über das Objekt mit bestimmen kann.

Eine Konsensfunktion entscheidet über die Ausführung der Kontrolle. Dabei kann eine Zustimmung von $\frac{1}{2}|O|$ eine Ausführung bedingen. Man spricht von einer \textbf{majorität}. Eine Zustimmung von $\frac{2}{3}|O|$ heißt \textbf{super majorität}.


% Intuitiev sollte der initialle Besitzer eines Inhalts sein Schöpfer sein. Dieser kann sein Besitz bei einer einigung an dritte abgeben, oder der Allgemeinheit überlassen. Bei einem Kollaborativ entstandenem Inhalt, bewerten die Besitzer die Beiträge


% Die Funktion $w_O: A \rightarrow \mathbb{N}$ gibt den Anteil von O an, der im Besitz von einem Akteur ist. 

% Gilt $share_O(a) > 0$, so nennt man $a$ auch ein \textbf{Member} von $O$.
% 
% $M_O \subseteq A$ ist die Menge aller Member von $O$.



\subsubsection*{Transaktionen}

Transaktionen sind Manipulationen des derzeitigen Zustandes des Objektes. Sie werden \textbf{immer} von einem Akteur $a$ ausgelöst und besitzen die Form $(a, O')$. $O'$ ist dabei das manipulierte geteilte Objekt. \textbf{Transaktionsbedingungen} entscheiden über die Validität der Transaktion und demnach über ihre Anwendung.

Wir betrachten vorerst nur die Manipulation der Kandidatenmenge $K$ sowie der Kandidatenbewertung $rate$. 

Eine triviale Transaktionsbedingung ist, dass sich in der Kandidatenmänge nur valide Kandidaten befinden.


\subsubsection*{Konsens}

  \[consens: A\times K\times w \times rate \rightarrow L(G)\] 


Die Konsensfunktion liefert für jedes Objekt ein Wort aus der $L(G)$ Sprache.
Dabei sucht die Funktion nach dem Kandidaten aus der Kandidatenmenge mit der maximalsten Bewertung. Die Bewertung eines Kandidaten ergibt sich dabei durch die Summe der gewichteten Bewertungen der Akteure.

\[ consens (A,K_G,w,rate) := \max_{k\in K_G} ( \sum_{a\in A} w(a) * rate(a,k) ) \] 


\subsubsection*{Bewertung}

%todo: bewertung kann kontextfrei sein -> an die spracherweiterung binden? 
%todo: für kontextsensitive bewertungen gibt es 1) deligationen und 2) direkte kandidatenbewertungen

\subsubsection*{Qualitätskriterien}

Für die Implementation ist auf folgende Qualitätskriterien zu achten:

\begin{description} 
  \item[\textbf{RESMIN:}]\hfill \\
    Es sind möglichst wenig Ressourcen (Speicher und Rechenleistung) vom Ethereum-Netzwerk notwendig, um Transaktionen zu validieren.
  \item[\textbf{INTMIN:}]\hfill \\
    Eine Akteur soll möglichst wenig Interaktionen benötigen, um auf eine gewünschte, von ihm erreichbare Manipulation zu kommen.
\end{description}

% 
%   * die Kandidatenmenge muss komprimiert werden, damit deren Speicherung möglichst wenig Speicher in anspruch nimmt.
%   * die validierung der manipulation muss eine kleine laufzeit haben.

% 

% es ist einfach für einen Akteur eine Bewertung über viele Kandidaten abzugeben.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     IMPLEMENTATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Anwendung auf reguläre Grammatiken}

\subsection{Optimierung der Kandidatenmenge}
Die reguläre Grammatik wird zu einer contextfreien Grammatik erweitert, so dass alle Wöterer aus der Kandidatenmenge in einem Wort der erweiterten Grammatik codiert werden können. Redundant auftauchende präfixe der Kandidaten werden zusammengefasst. Dafür wird an jedem Ableitungsschrit eine Mehrdeutigkeit zugelassen die zu einer \textbf{Optionsmenge} zusammengefasst wird. Die Kandidatenmenge ergibt sich durch die verschiedenen Kombination der mehrdeutigen Ableitung.

Dazu muss es eine Grammatikerweiterung $S: REG\rightarrow CFG$ gefunden werden.
Um zu zeigen, dass es sich bei $S$ um die gesuchte Erweiterung handelt, muss die Existenz der Funktionen $\phi: P(K_G) \rightarrow L(S(G))$ und $\phi^{-1}: L(S(G)) \rightarrow P(K_G)$ gezeigt werden, für die folgende Bedingungen erfüllt sein müssen:

\begin{align}
  \phi\circ\phi^{-1} &= id_{P(K_G)} \\
  |\phi(K_G)| &\lesssim \sum_{k\in K_G} |k|
\end{align}


Die Bedingung (1) kann auch abgeschwächt werden zu $K_G\subseteq \phi\circ\phi^{-1}(K_G)$. Dieses würde bedeuten, dass Informationen über Kandidaten nicht verlohren gehen, jedoch hinzukommen können, solange diese valide Kandidaten bilden.

In Bedingung (2) werden Edge-Cases ausgeschlossen, die nur bei kleinen diversen lösungen auftauchen können. (z.B.: $\{a\ b\}$)


% \subsection{Qualitätskritärien}
% 
% \begin{enumerate}
%   \item die wörter der Sprache $L(SCFG)$ sind möglichst klein
%   \item es ist einfach Optionen zu Bewerten: Die Anzahl der transitionen ist möglichst klein, um auf ein gewünschtes Bewertungsprofil zu kommen.
%     
%     Sei $a\in A$ ein Akteur, sei $X_i\subseteq P\times [0,1]$ die derzeitige Bewertung der Programme von $a$ und sei $X_j\subseteq P\times [0,1]$ die gewünschte Bewertung. Sei $t$ eine von $a$ gültige Transformation, so dass $X_k \rightarrow_{t} X_{k+1}$ und sei T die Menge der von a gültigen Transformationen. Die Bewertung ist einfach, wenn für $X_i \rightarrow_{ T }^n X_j$ n möglichst minimal ist.
% \end{enumerate}

\subsubsection*{Grammatikerweiterung S1}

Sei $G = (N,T,S,P)$ eine reguläre Grammatik.


$
\begin{array}{rl}
  S_1(G) :=& (N', T', S, P') \\
  N' :=& N \cup \{ O_R\ |\ (R\rightarrow r)\in P\land O_R \notin N\}\\
  T' :=& T \cup \{[ , ]\ |\ [,]\notin T \}\\
  P' :=& P
  \cup P_{Options} 
  \\
  P_{Options} :=& \{R \rightarrow [O_R], O_R \rightarrow r O_R, O_R \rightarrow \varepsilon \ \vert\ R\rightarrow r\in P
  \land r\in (N\cup T)^*\} \\
\end{array}
$

\subsubsection*{Definition $\phi$}

\TODO[inline]{Definition $\phi$}

\subsubsection*{Definition $\phi^{-1}$}

\TODO[inline]{Definition $\phi^{-1}$}

\subsubsection*{zeige $\phi\circ\phi^{-1} = id_{P(K_G)}$}
  
\TODO[inline]{zeige $\phi\circ\phi^{-1} = id_{P(K_G)}$}

\subsubsection*{zeige $|\phi(K_G)| \lesssim \sum_{k\in K_G}$}

\TODO[inline]{zeige $|\phi(K_G)| \lesssim \sum_{k\in K_G}$}


\subsection{Optimierung der Kandidatenbewertung}

\subsubsection*{Komprimierung}

Die Idee hinter der Optimierung der Bewertung ist, dass Aktuere für eine Option stimmen möchten, im kontext zu ihrer historie, gleich welche Optionen sich im verlauf als die Besten herausstellen werden und nicht für individuelle Kandidaten. Wobei die Abstimmung für einen bestimmten Kandidaten ebenfalls mit berücksichtigt werden soll.
Daher kann mann Stimmen an Optionen binden, die selbst unbestimmte Optionen enthalten, für die diese Simme ebenfalls geltend gemacht wird.

Eine Bedingung an die Optimierung ist, das jede mögliche Kandidatenbewertung in der Optimierung codierbar ist. 


\subsubsection*{zeige: eine beliebige Kandidatenbewertung ist in S2 codierbar.}
\TODO[inline]{zeige: eine beliebige Kandidatenbewertung ist in S2 codierbar.}

% Sei \phi_w die funktion, die jedem kandidaten einen wert zuordnet.
% idee hinter dem beweis ist, das die letzte geschachtelte option und somit die Bewertung nirgendwo mehr auftaucht. wenn diese -1 <= w <= 1 sein kann, die bewertung des pfades vorher ebenfalls 0 <= p <= 1 ist, so ist  p_i = min( max( p + w, 0 ), 1) so, dass 0 <= p_i <= 1 

% kandidatenbewertungen nur optionen ohne vergeben, die keine optionen besitzen? Wird eine option an einen knoten darüber vergeben, wird diese von den darunterliegenden überschrieben.


\subsubsection*{Delegationen}

Für die minimierung der interaktion wird transitives Voting zugelassen. Akteure können nicht nur für die Option selbst abstimmen, sondern auch ihre Stimme für Optionsmengen an andere Akteure deligieren, so dass diese im Kontext der delegierten Option für den Akteur mitbestimmen.

%Durch die notwendig lineare Struktur der worte und somit auch der Delegationsmengen ergibt sich nicht nur eine Menge der Delegationen für eine Optionsmenge sondern auch eine totale Ordnung der delegationen, womit bei konkurierenden Delegationen immer die ranghöste genommen wird. 

\TODO[inline]{konkurierende deligationen}

% Meine erste Idee war es. Abstimmungen an Optionen zu binden. Dadurch würde sich ein Präferenzprofiel für einen Akteur ergeben, bei dem der Akteur die Kandidaten am besten Bewertet, bei denen die meisten Optionen enthalten sind, für die er sich ausgesprochen hat. Ein solchens vorgehen ist zwar bei kontextfreien inhalten sinvoll, da jedoch durch Programme ein kontextsensitiver Inhalt dargestellt ist, muss ein beliebiges Präferenzprofiel über der Kanddatenmenge möglich sein, dieses ist jedoch nicht möglich, wenn die Abstimmungen an Optionen gebungen werdnen.


\subsubsection*{Besitzverteilung}

Schließlich wird die Besitzverteilung ebenfalls als Teil der erweiterten Sprache angesehen. Dies erlaubt nun den Konsens des Objektes als Interpretation eines Wortes der $L(S(G))$ Sprache zu definieren. Ebenfalls können Transitionen als valide Manipulationen eines Wortes definiert werden. Transitionsbedingungen können so auf der Ableitungsstruktur des Wortes definiert werden.

Akteure werden durch einen 20 byte hex String codiert.



% \textbf{number} stellt eine ganzzahlige Nummer dar. \textbf{float}
% stellt eine fließkommazahl dar. \textbf{hash} ist ein identifikatior für
% einen akteur, hier ein 20 bytes hex string.



% $P_{Options} := \{R \rightarrow [O][D], O \rightarrow r\oplus [V] O \vert R\rightarrow r\in P$




\subsubsection*{Grammatikerweiterung S}


$
\begin{array}{rl}
  S(G) :=& (N', T', S', P') \\
  N' :=& N \cup \{ O_R | (R\rightarrow r)\in P\land O_R \notin N\}\cup\{D, A\}\\
  T' :=& T \cup \{[ , ], \oplus, number, float, hash\ |\ [,],\oplus \notin T \}\\
  P' :=& P
  \cup P_{Options} 
  \cup P_{Start} 
  \cup P_{Delegations} 
  \cup P_{Voting} 
  \cup P_{Acteurs}
  \\
  P_{Acteurs} :=& \{A\rightarrow[hash\ number]A,A\rightarrow \varepsilon\} \\
  P_{Options} :=& \{R \rightarrow [O_R][D], O_R \rightarrow r\oplus [V] O_R, O_R \rightarrow \varepsilon \ \vert\ R\rightarrow r\in P
  \land r\in (N\cup T)^*\} \\
  P_{Start} :=& \{S'\rightarrow [A]S\} \\
  P_{Delegations} :=& \{D\rightarrow [hash\ hash]D,D\rightarrow [hash\ hash]\} \\
  P_{Voting} :=& \{V\rightarrow [hash\ float]V, V \rightarrow \varepsilon\}
\end{array}
$

\TODO[inline]{start als optionsmenge}


\subsubsection*{zeige S(G) ist eindeutig}
\TODO[inline]{zeige S(G) ist eindeutig}


\subsection{Konsens}

\TODO[inline]{definiere $consens: L(S(G)) \rightarrow L(G)$}

% Die Idee hier ist, dass die transitive Hülle der Delegationen als
% Attribut während der Ableitung vererbt(inherited) wird. Die Votemenge
% wird hingegen als Attribut synthetisiert. Die Delegationen zusammen mit
% den Stimmen quantifizieren jede Option aus einer Optionsmenge und wählen
% eine Konsens-Option.

% Sei $\alpha,\beta$ und $o$ Wörter über dem Terminalalphabet. 
% 
% \[ \alpha, \beta, o \in T^* \] 
% 
% Sei $W_\alpha^\beta\subseteq K_G$ die Menge der Wörter, die $\alpha$ als Prefix und $\beta$ als Suffix besitzen. 
% 
% \[W_\alpha^\beta:=\{w|w=\alpha o\beta\land w\in K_G\}\]
% 
% 
% Falls $|W_\alpha^\beta|>1$ sowie $|\alpha| + |\beta| > 0$ gilt, folgt aus der Eindeutigkeit der Ableitung von $G$, dass es eine Regel $(R\rightarrow r)\in P$ exestieren muss, so dass $S \rightarrow^*_P \alpha R \beta$, sowie $\forall \alpha o \beta \in W_\alpha^\beta: R \rightarrow_P^* o$.
% 
% Sei $O_\alpha^\beta := \{o\in T^* | \alpha o \beta \in W_\alpha^\beta \}$, so reicht es $\alpha, \beta$ sowie jedes Element von $O_\alpha^\beta$ anzugeben, um die Menge zu beschreiben. 

% \subsubsection*{Algorithmus}

% Sei $O^R:=\{w| R \rightarrow^* w \}$. Wir definieren $O_r \subseteq O^R$ als die Teilmenge der Wörter von $O^R$, die durch die Regelausführung $(R\rightarrow r)\in P$ gebildet wurden.  \\
% 
% 
% \begin{algorithm}
%   
% \caption{$\phi: P(K_G) \rightarrow L(S(G))$}\label{euclid}
% \begin{algorithmic}[1]
% \Function{$\phi$}{$K_G$}
% \State\Return \Call{combine}{$K_G, S$}
% \EndFunction
% \\
% 
% \Function{combine}{$O^R, R$} 
% \If {$|O^R| = 1$}
%     \Return $o\in O^R$
% \Else
%   \State $W \gets \{\}$
%   \For{ $(R\rightarrow r)\in P$ }
%     \State $O_{r} \subseteq O^R$
%     \State $W\gets W\cup$ \Call{parse}{$O_r, r$}
%   \EndFor
%   \If {$|W|=1$}
%   \State\Return $w\in W$
%   \Else
%   \State\Return $[w_0 w_1 ... w_{|W|}]$
%   \EndIf
% \EndIf
% \EndFunction  
% \\
% 
% \Function{parse}{$O_r, r=s_0s_1...s_n$} 
%   \State $o\gets \epsilon$
%   \For{ $i\gets 0...n$ }
%     \If{$s_i\in T$}
%       \State$o \gets o \circ s_i$
%     \Else
%       \State$o \gets o \circ $ \Call{combine}{$O^s_i, s$}
%     \EndIf
%   \EndFor
% \EndFunction
% 
% \end{algorithmic}
% \end{algorithm}

% In Zeile (27) steht $O^s$ für die Menge der teilweörter von O, die an der Stelle von s, durch die regel R erzeugt werden.

% \TODO[inline]{Definition und Algorithmus für $O^s_i$ angeben.}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    MANIPULATION 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Transitionssystem}

% so dass alle Transaktionen des Objektes als Transaktionen eines contextfreien Wortes angesehen werden können. Die Transaktionsbedingungen können als Struktur des Wortes aufgefasst werden.

Die Idee hinter der manipulation ist des es sich bei den Wörter um eine Persistente Datenstruktur handelt. Demnach können Optionen nur hinzu kommen, jedoch nicht gelöscht werden. Jeder Akteur kann Delegationen und Stimmen abgeben sowie
die eigenen löschen, hat jedoch keine Macht über die Stimmen und
Delegationen der Anderen.

Die Manipulation wird durch ein \textbf{initialisiertes Transitionssysthem $T$}
beschrieben.

Sei $G = (N,T,S,P)$ eine rechtsreguläre Grammatik sowie
$S(G)=(N',T',S',P')$ die dazugehörige erweiterte Grammatik.

% \subsection{Qualitätskritärien}
% 
% \begin{enumerate}
%   \item operationen wie $vote, delegate, addOption$ sind effizient in bezug auf Laufzeit und Speicherverbrauch.
%   \item Die Verifikation der Transaktion durch das Netzwerk soll möglichst effizient sein.
% \end{enumerate}

\subsubsection*{Zustände}

Ein Zustand der ist eine Struktur der form $(U, consens, w)$

U ist das Universum der Struktur und wird definiert durch:
\[U := L(S(G))\]

$consens$ ist die für $L(S(G))$ definierte konsens Funktion:
$w\in U$ ist das derzeitige Wort

\subsubsection*{Transitionenbedingungen}

\TODO[inline]{transitionsbedingungen sind für $CFG$ definiert: ändern}

\subsubsection*{Erzeugen einer Optionsmenge}
% Bedingung ist, dass die kandidatenbewertung bei der erzeugung nicht manipuliert wird

\begin{center}
\Tree [.O $\alpha$ [.R $o_1$ ] $\oplus$ $\lbrack$ [.V v ] $\rbrack$ ]
\end{center}

\begin{center}
\Tree [.O $\alpha$ [.R $\lbrack$ [.O $o_1$ $\oplus$ $\lbrack$ [.V v ]  $\rbrack$ [.O $o_2$ $\oplus$ $\lbrack$ [.V $\epsilon$ ] $\rbrack$ ] ] $\rbrack$ $\lbrack$ [.D $\epsilon$ ] $\rbrack$ ] $\oplus$ $\lbrack$ $\rbrack$ ]
\end{center}


Sei $\alpha,\beta,o_1,o_2 \in T'^*$ sowie $O\neq R \land R\in N$ und
$V \rightarrow_P^* v$ 
Sei $w=\alpha o_1 \beta \oplus [v]$Sei weiter
$R\rightarrow_p^* o_1$ sowie $R\rightarrow_p^* o_2$ Dann ist
$w:=\alpha [o_1\oplus [v] o_2\oplus []][]\beta$ eine valide Transition.

\subsubsection*{Erweitern einer Optionsmenge}
% Bedingung ist, dass die kandidatenbewertung bei der erzeugung nicht manipuliert wird

Sei $w=\alpha[o]\beta \land S'\rightarrow_P^* \alpha R \beta$ mit
$O\rightarrow_P^* o, o\in T'^*, R\in N$ Dann ist
$w:=\alpha[o r\oplus []]\beta$ mit $R \rightarrow_P^* r, r\in T'^*$ eine
valide Transition.

\subsubsection*{Hinzufügen einer Stimme}

Sei $w=\alpha r\oplus [v]\beta$

Dann ist $w:=\alpha r \oplus [v[h n]]\beta$ mit $n=float$ eine valide
Transition.

\subsubsection*{Löschen einer Stimme}

Sei $w=\alpha [hn]\beta$

Dann ist $w:=\alpha\beta$ mit eine valide Transition.

\subsubsection*{Hinzufügen einer Delegation}
Analog der Stimme

\subsubsection*{Löschen einer Delegation}
Analog der Stimme

\subsection{Delegationsprogrammierung}

\paragraph{Context Delegation}
\paragraph{Validator}
\paragraph{A/B Tester}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      IMPLEMENTATIONSPLAN
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Umfang der Arbeit}

\subsection*{Konzeptuell}
\begin{itemize}
  \item Die Punkte unter Aufgaben (TODO's) werden ausformuliert.
  \item Dieses Papier wird mit anschaulichen Beispielen, Erklärungen, Quellen sowie verweisen und Erklärungen grundlegender Konzepte ergänzt. Solche Konzepte währen: 
    \begin{itemize}
      \item reguläre/ contextfreie Grammatik, normalformen
      \item algebraisches Transitionssystem
    \end{itemize}
  \item Die Punkte unter Aussicht werden diskutiert, jedoch weder implementiert, noch im Umfang der Anwendung auf die regulären Grammatiken konzipiert.
\end{itemize}


\subsection*{Implementation}
\begin{itemize}
  \item Eine Zentralisierte Version der $L(S(G))$-Sprache sowie des Transitionsysthems wird implementiert 
  \begin{itemize}
    \item JISON\footnote{http://jison.org/}, eine javascript Portierung des Bison\footnote{http://www.gnu.org/software/bison/}/Flex\footnote{http://flex.sourceforge.net/} LALR(1) Parser Generators wird so erweitert, dass bei Eingabe einer beliebigen Grammatik $G$ dieser einen Parser erzeugt welcher Wörter aus der $L(S(G))$ Sprache als Eingabe bekommt und ein öffentliches Transitionsysthem erzeugt.
 States   \item Ein Initialscript, welches aus einem Wort der $L(G)$ Sprache und einer Besitzgewichtung gegeben als $\{(a,n)| a\in\ 20byteHexString \land n\in \mathbb{N} \}$ ein valiedes initiales Wort in der $L(S(G))$ Sprache erzeugt 
    \item Akteure können durch eine Öffentliche Schnittstelle( Webseite ) in die Historie einsehen, sowie das Wort valide manipulieren.
    \item Eine client-seitige asymetrische Verschlüsselung validiert die Akteure.
    \item Die Konsensfunktion wird ebenfalls Implementiert und steht öffentlich verfügbar.
  \end{itemize}
\end{itemize}

\subsection*{Todos}

\listoftodos[Aufgaben]



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%       Aussicht
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Aussicht}

\subsection*{Anwendung auf contextfreie Grammatiken}

% Die validität einer Sprache ist jedoch meist nicht nur aus der kontextfreien syntax zu schließen. So werden namensresolutionen und typisierung beim compilieren in späteren schritten auf eine kontext sensitive weise überprüft. Dies
% Syntax von Programmiersprachen sind nicht kontextfrei, sondern Kontextsensitiv \cite{Otto}

% Validitätskritärien: Objekt hängt von keiner Grammatik ab, sondern von einer Mänge von Validitätskritärien von denen die Grammatik eine sein kann. Die validitätskritärien schränken den Raum der Kandidaten automatisch ein. Die ausgewählten Kandidaten der Kandidatenmenge sind somit alle valide. Ihre bewertung sind präferrenzen der akteure.
% \[ K \subseteq VK \subseteq \bigcap_{v\in V} v \] 

\subsection*{Dezentralisierung}

\subsection*{Anonymisierung}

\subsection*{Manipulation der Besitzverteilung}
\subsection*{Manipulation der Grammatik}


\begin{itemize}
  \item änderungen der Grammatik berücksichtigen
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      QUELLEN
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage
\section{Quellen}


\bibliography{library}

\bibliographystyle{alpha}

\end{document}

