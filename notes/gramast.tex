% todo: refactor S(G) to gamma


\documentclass[]{article}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript

% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[utf8x]{inputenc}
\else % if luatex or xelatex
  \usepackage{fontspec}
  \ifxetex
    \usepackage{xltxtra,xunicode}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{€}
\fi
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            pdfauthor={},
            pdftitle={},
            colorlinks=true,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

% Treeview
\usepackage{tikz}
\usepackage{tikz-qtree}

% Graphviz
\usepackage{graphvizzz}

% Source Code so found here: http://en.wikibooks.org/wiki/LaTeX/Source_Code_Listings
\usepackage{listings}

% Definitionen
\usepackage{amsthm}

% Algorithmen
\usepackage{algpseudocode}
\usepackage{algorithm}

%todo 
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}

\usepackage{xargs}                      % Use more than one optional parameter in a new commands

\newcommandx{\TODO}[2][1=]{\todo[linecolor=none,backgroundcolor=gray!25,bordercolor=none,#1]{\textbf{TODO: }#2}}

\def\signed #1{{\leavevmode\unskip\nobreak\hfil\penalty50\hskip2em
  \hbox{}\nobreak\hfil(#1)%
  \parfillskip=0pt \finalhyphendemerits=0 \endgraf}}

\newsavebox\mybox
\newenvironment{aquote}[1]
  {\savebox\mybox{#1}\begin{quote}}
  {\signed{\usebox\mybox}\end{quote}}


\newtheorem{mydef}{Definition}
\renewcommand*\contentsname{Inhaltsverzeichnis}

\author{Denis Erfurt}
\date{\now}
\title{Ein dezentrales Transitionssystem zur verteilten Steuerung von Inhalten einer regulären Sprache}


\begin{document}


\tableofcontents


\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      EINLEITUNG
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Einleitung}

% Es geht um Akteure, Besitz, Bewertung
Im Internet werden zunehmend Inhalte kollaborativ erzeugt. 
Dabei entsteht ein Inhalt durch Beiträge einzelner \textbf{Akteure}.
Zentral ist die Frage nach dem \textbf{Besitz} des Inhaltes sowie die \textbf{Bewertung} der einzelnen Beiträge durch die Besitzer und damit ihren Anteil am \textbf{Gesamtergebnis}. 


% Problem: der Verwaltung( Manipulation ) und der besitzallokation
In dieser Arbeit wird dieses Problem für Inhalte einer regulären Sprache untersucht. Dafür wird ein dezentral validiertes Transitionssystem vorgestellt welches die Manipulation eines öffentlichen Ihnaltes durch Akteure steuert. Dafür wird eine Grammatik-Erweiterung vorgestellt, dessen Wörter Informationen über die Besitzallokation der Akteure, alternative Inhalte sowie deren Bewertung durch die Akteure beinhalten. Der Konsens der Akteure über den Inhalt wird als Interpretation des Wortes berechnet und ist durch die verfügbaren Informationen determiniert. 

\newpage




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      VERIFIZIERUNG 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Dezentrale Verifizierung}

Das auf dem Bitcoin-Protokoll\cite{Nakamoto2008} aufbauende Ethereum \cite{Wood2014}, beschreibt ein P2P Protokoll zur dezentralen Verifizierung von Turing-Vollständigen Programmausführungen. 
Es stellt einen gebildeten Konsens von Programmen mit aktuellen Zuständen bereit. 
Neue Inhalte wie neue Programme oder neue Interaktionen von Akteuren mit Programmen werden nach einer Veröffentlichung und Validierung der Ausführung durch das Netzwerk mit dem neu berechnetem Zustand in den Konsens aufgenommen.

Agierende Instanzen sind einerseits externe Akteure, die durch ein asymmetrisches Kryptosystem mit anderen Akteuren im Netzwerk interagieren. Andererseits sind Akteure Turing-Vollständige Programme, die vom Netzwerk bereitgestellt werden. Solche Akteure werden auch (smart-)\textbf{contracts} genannt.
Akteure sowie Contracts werden durch ein 20-Byte Adresse identifiziert.

Die Validierungsknoten des Ethereum-Netzwerks finanzieren sich einerseits durch die Neuschöpfung einer internen Währung, sowie durch einen Betrag, der für die Validierung einer Programmausführung von einem Akteur bezahlt wird. Für jeden Berechnungsschritt der Ethereum-VM wird dafür ein kleiner Betrag erhoben. Ist nicht genügend Wert verfügbar, terminiert die Transaktion und wird vom Netzwerk abgelehnt. So wird auch das Halteproblem umgangen.

\begin{aquote}{Ethereum Whitepaper p. 28 \cite{Butterin2014}}
  [...] halting problem: there is no way to tell, in the general case, whether or not a given program will ever halt.
  [...] our solution works by requiring a transaction to set a maximum number of computational steps that it is allowed to take, and if execution takes longer computation is reverted but fees are still paid.
\end{aquote}


Ein Contract besteht aus einem assoziativem Speicher der den Programmcode sowie Daten beinhaltet.

Ein Beispiel für ein Programm ist eine dezentrale Währung, wie sie derzeit vom Bitcoin Protokoll repräsentiert wird (Quelle \cite{Butterin2014}):

% ! Akteure = Programme | Benutzer

\begin{lstlisting}
  from = msg.sender
  to = msg.data[0]
  value = msg.data[1]

  if self.storage[from] >= value:
  self.storage[from] = self.storage[from] - value
  self.storage[to] = self.storage[to] + value
\end{lstlisting}


Eine neue interessante Anwendung ist ein \textbf{geteilter} manipulierbar Inhalt, im folgenden Objekt genannt. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   GETEILTES OBJEKT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Digital Geteiltes Objekt}
\subsection{Definition}

Ein \textbf{geteiltes digitales Objekt} ist ein Tupel $O_G=(A, K, w, rate, consens)$ bestehend aus:

\begin{enumerate}
\item Eine endliche Menge von Akteuren $A$
\item Eine eindeutige \textbf{Besitzverteilung} von Akteuren zum Objekt
  \[w: A \rightarrow \mathbb{N}\]
\item eine endliche Menge von validen \textbf{Kandidaten} mit mindestes einem Element 
  \[K_G \subseteq L(G) \land |K_G| \geq 1\] 
\item eine Bewertung der Kandidaten durch die Akteure. 
  \[rate: A\times K \rightarrow [0,1]\]
\item einer Konsensfunktion
  \[consens: A\times K\times w \times rate \rightarrow L(G)\] 
\end{enumerate}

Sei $\mathbf{SOBJ_G}$ die Menge aller geteilten Objekte in der Grammatik $G$ sowie 
 $\mathbf{P_G}:= \{ K_G | K_G \subseteq L(G) \}$ die Menge aller möglichen Kandidatenmengen.

\subsection {Erläuterung}


\subsubsection*{Besitzverteilung}

%Aktienmodell

Die Besitzverteilung wird ähnlich dem Aktienmarkt Modelliert. Dabei hat ein geteiltes Objekt eine bestimmte Anzahl an Teilen (geschrieben $|O| \in \mathbb{N}$), die unter den Akteuren aufgeteilt sind. 
\[ |O| := \sum_{a \in A} w(a) \] 

% Besitz = Bestimmung
Der Besitz eines Objekts $O$ wird durch das Recht definiert, auf dieses zugreifen zu können und es Kontrollieren zu können\cite{Waldron2004}. Besitzen mehrere Akteure ein Objekt, so gibt der Anteil am Objekt an, zu welcher Gewichtung jeder einzelne Akteur über das Objekt mitbestimmen kann.

Eine Konsensfunktion entscheidet über die Ausführung der Kontrolle.
% Dabei kann eine Zustimmung von $\frac{1}{2}|O|$ eine Ausführung bedingen. Man spricht von einer \textbf{majorität}. Eine Zustimmung von $\frac{2}{3}|O|$ heißt \textbf{super majorität}.


% Intuitiev sollte der initialle Besitzer eines Inhalts sein Schöpfer sein. Dieser kann sein Besitz bei einer einigung an dritte abgeben, oder der Allgemeinheit überlassen. Bei einem Kollaborativ entstandenem Inhalt, bewerten die Besitzer die Beiträge


% Die Funktion $w_O: A \rightarrow \mathbb{N}$ gibt den Anteil von O an, der im Besitz von einem Akteur ist. 

% Gilt $share_O(a) > 0$, so nennt man $a$ auch ein \textbf{Member} von $O$.
% 
% $M_O \subseteq A$ ist die Menge aller Member von $O$.



\subsubsection*{Transaktionen}

Transaktionen sind Manipulationen des Objektes. Sie werden \textbf{immer} von einem Akteur $a$ ausgelöst und besitzen die Form $(a, O')$. $O'$ ist dabei das manipulierte geteilte Objekt. \textbf{Transaktionsbedingungen} entscheiden über die Validität der Transaktion und demnach über ihre Anwendung.

Wir betrachten vorerst nur die Manipulation der Kandidatenmenge $K$ sowie der Kandidatenbewertung $rate$. 

% Eine triviale Transaktionsbedingung ist, dass sich in der Kandidatenmänge nur valide Kandidaten befinden.


\subsubsection*{Konsens}

  \[consens: A\times K\times w \times rate \rightarrow L(G)\] 


Die Konsensfunktion liefert für jedes Objekt ein Wort aus der $L(G)$ Sprache.
Dabei sucht die Funktion nach dem Kandidaten aus der Kandidatenmenge mit der maximalsten Bewertung. Die Bewertung eines Kandidaten ergibt sich dabei durch die Summe der gewichteten Bewertungen der Akteure.

\[ consens (A,K_G,w,rate) := \max_{k\in K_G} ( \sum_{a\in A} w(a) * rate(a,k) ) \] 


% \subsubsection*{Bewertung}

%todo: bewertung kann kontextfrei sein -> an die spracherweiterung binden? 
%todo: für kontextsensitive bewertungen gibt es 1) deligationen und 2) direkte kandidatenbewertungen

\subsubsection*{Qualitätskriterien}

Für die Implementation ist auf folgende Qualitätskriterien zu achten:

\begin{description} 
  \item[\textbf{RESMIN:}]\hfill \\
    Es sind möglichst wenig Ressourcen (Speicher und Rechenleistung) vom Ethereum-Netzwerk notwendig, um Transaktionen zu validieren.
  \item[\textbf{INTMIN:}]\hfill \\
    Eine Akteur soll möglichst wenig Interaktionen benötigen, um auf eine gewünschte, von ihm erreichbare Manipulation zu kommen.
\end{description}

% 
%   * die Kandidatenmenge muss komprimiert werden, damit deren Speicherung möglichst wenig Speicher in anspruch nimmt.
%   * die validierung der manipulation muss eine kleine laufzeit haben.

% 

% es ist einfach für einen Akteur eine Bewertung über viele Kandidaten abzugeben.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     IMPLEMENTATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Anwendung auf reguläre Grammatiken}

\subsection{Optimierung der Kandidatenmenge}
Die reguläre Grammatik wird so zu einer kontextfreien Grammatik erweitert, dass alle Wörter aus der Kandidatenmenge in einem Wort der erweiterten Grammatik codiert werden können. Redundant auftauchende Präfixe der Kandidaten werden zusammengefasst. Dafür wird an jedem Ableitungsschritt eine Mehrdeutigkeit zugelassen die zu einer \textbf{Optionsmenge} zusammengefasst wird. Die Kandidatenmenge ergibt sich durch die Kombinationen der Präfixe mit den Optionen einer Optionsmenge.

Dazu muss es eine Grammatik-Erweiterung $S: REG\rightarrow CFG$ gefunden werden.
Um zu zeigen, dass es sich bei $S$ um die gesuchte Erweiterung handelt, muss die Existenz der Funktionen $\phi: P(K_G) \rightarrow L(S(G))$ und $\phi^{-1}: L(S(G)) \rightarrow P(K_G)$ gezeigt werden, für die folgende Bedingungen erfüllt sein müssen:

\begin{align}
  \phi\circ\phi^{-1} &= id_{P(K_G)} \\
  |\phi(K_G)| &\lesssim \sum_{k\in K_G} |k|
\end{align}


Die Bedingung (1) kann auch abgeschwächt werden zu $K_G\subseteq \phi\circ\phi^{-1}(K_G)$. Dieses würde bedeuten, dass Kandidaten nicht verloren gehen, jedoch hinzukommen können, solange diese valide Kandidaten bilden.

In Bedingung (2) werden Edge-Cases ausgeschlossen, die nur bei kleinen diversen Lösungen auftauchen können. (z.B.: $\{a\ b\}$)


% \subsection{Qualitätskritärien}
% 
% \begin{enumerate}
%   \item die wörter der Sprache $L(SCFG)$ sind möglichst klein
%   \item es ist einfach Optionen zu Bewerten: Die Anzahl der transitionen ist möglichst klein, um auf ein gewünschtes Bewertungsprofil zu kommen.
%     
%     Sei $a\in A$ ein Akteur, sei $X_i\subseteq P\times [0,1]$ die derzeitige Bewertung der Programme von $a$ und sei $X_j\subseteq P\times [0,1]$ die gewünschte Bewertung. Sei $t$ eine von $a$ gültige Transformation, so dass $X_k \rightarrow_{t} X_{k+1}$ und sei T die Menge der von a gültigen Transformationen. Die Bewertung ist einfach, wenn für $X_i \rightarrow_{ T }^n X_j$ n möglichst minimal ist.
% \end{enumerate}

\subsubsection*{Grammatik-Erweiterung S1}

Sei $G = (N,T,S,P)$ eine reguläre Grammatik.


$
\begin{array}{rl}
  S_1(G) :=& (N', T', S, P') \\
  N' :=& N \cup \{ O_R\ |\ (R\rightarrow r)\in P\land O_R \notin N\}\\
  T' :=& T \cup \{[ , ]\ |\ [,]\notin T \}\\
  P' :=& P
  \cup P_{Options} 
  \\
  P_{Options} :=& \{R \rightarrow [O_R], O_R \rightarrow r O_R, O_R \rightarrow \varepsilon \ \vert\ R\rightarrow r\in P
  \land r\in (N\cup T)^*\} \\
\end{array}
$

\subsubsection*{Definition $\phi$}

\TODO[inline]{Definition $\phi$}

\subsubsection*{Definition $\phi^{-1}$}

\TODO[inline]{Definition $\phi^{-1}$}

\subsubsection*{zeige $\phi\circ\phi^{-1} = id_{P(K_G)}$}
  
\TODO[inline]{zeige $\phi\circ\phi^{-1} = id_{P(K_G)}$}

\subsubsection*{zeige $|\phi(K_G)| \lesssim \sum_{k\in K_G}$}

\TODO[inline]{zeige $|\phi(K_G)| \lesssim \sum_{k\in K_G}$}


\subsection{Optimierung der Kandidatenbewertung}

\subsubsection*{Komprimierung}
Die Idee hinter der Komprimierung ist, die Bewertung der Kandidaten an Optionen zu binden. Wenn ein Akteur eine Option in einer Optionsmenge bewertet, so gibt er seine Stimme der Option im Kontext zu dem bisherigen Präfix des Wortes. Somit werden alle Kandidaten, die sich mit dem Präfix und der Option erzeugen lassen von der Stimme beeinflusst. Diese wird als ein Attribut der Ableitung vererbt\cite{Knuth1968} und jeweils von einer Bewertung einer tieferen Ebene ersetzt. Eine wichtige Bedingung ist, dass jede mögliche Bewertungsverteilung in der Optimierung codierbar ist. Dieses ist leicht zu zeigen, da die Bewertung aller Blätter des Ableitungsbaumes ebenfalls die Bewertung der Kandidaten repräsentiert.

% \subsubsection*{zeige: eine beliebige Kandidatenbewertung ist in S2 codierbar.}
% \TODO[inline]{zeige: eine beliebige Kandidatenbewertung ist in S2 codierbar.}

% Sei \phi_w die funktion, die jedem kandidaten einen wert zuordnet.
% idee hinter dem beweis ist, das die letzte geschachtelte option und somit die Bewertung nirgendwo mehr auftaucht. wenn diese -1 <= w <= 1 sein kann, die bewertung des pfades vorher ebenfalls 0 <= p <= 1 ist, so ist  p_i = min( max( p + w, 0 ), 1) so, dass 0 <= p_i <= 1 


\subsubsection*{Delegationen}

Für die Minimierung der Interaktion wird transitives Abstimmen zugelassen. Akteure können nicht nur für die Option selbst abstimmen, sondern auch ihre Stimme für Optionsmengen an andere Akteure so delegieren, dass diese im Kontext der delegierten Option für den Akteur mitbestimmen.

Durch die lineare Struktur der Worte und somit auch der Delegationsmengen ergibt sich nicht nur eine Menge der Delegationen für eine Optionsmenge, sondern auch eine totale Ordnung der Delegationen, womit bei konkurierenden Delegationen immer die Delegation höherer Ordnung genommen wird. 

\TODO[inline]{konkurierende Delegationen}

% Meine erste Idee war es. Abstimmungen an Optionen zu binden. Dadurch würde sich ein Präferenzprofiel für einen Akteur ergeben, bei dem der Akteur die Kandidaten am besten Bewertet, bei denen die meisten Optionen enthalten sind, für die er sich ausgesprochen hat. Ein solchens vorgehen ist zwar bei kontextfreien inhalten sinvoll, da jedoch durch Programme ein kontextsensitiver Inhalt dargestellt ist, muss ein beliebiges Präferenzprofiel über der Kanddatenmenge möglich sein, dieses ist jedoch nicht möglich, wenn die Abstimmungen an Optionen gebungen werdnen.


\subsubsection*{Besitzverteilung}

Schließlich wird die Besitzverteilung ebenfalls als Teil der erweiterten Sprache angesehen. Dies erlaubt nun den Konsens des Objektes als Interpretation eines Wortes der $L(S(G))$ Sprache zu definieren. Transformationen werden als valide Manipulationen eines Wortes definiert. Transformationsbedingungen geben dabei Anforderungen an die Ableitungsstruktur des bisherigen Wortes sowie an das Manipulierte Wort. Dieses determiniert die Validität einer Transaktion.

% Akteure werden durch einen 20 byte hex String codiert.







\subsubsection*{Grammatik-Erweiterung S}


\textbf{number} stellt eine ganzzahlige Nummer dar. \textbf{float}
stellt eine Fließkommazahl dar, so dass $0\leq float \leq 1$. \textbf{hash} identifiziert einen Akteur, hier ist $hash$ ein 20 Bytes HEX-String. \\

\begin{align}
  S(G) :=& (N', T', S', P') \\
  N' :=& N \cup \{ O_R | (R\rightarrow r)\in P\land O_R \notin N\}\cup\{D, A\}\\
  T' :=& T \cup \{[ , ], \oplus, number, float, hash\ |\ [,],\oplus \notin T \}\\
  P' :=& P
  \cup P_{Options} 
  \cup P_{Start} 
  \cup P_{Delegations} 
  \cup P_{Voting} 
  \cup P_{Acteurs}
  \\
  P_{Acteurs} :=& \{A\rightarrow[hash\ number]A,A\rightarrow \varepsilon\} \\
  P_{Options} :=& \{R \rightarrow [O_R][D], O_R \rightarrow r\oplus [V] O_R, O_R \rightarrow \varepsilon \ \nonumber\\
  &\vert\ R\rightarrow r\in P \land r\in (N\cup T)^*\} \\
  P_{Start} :=& \{S'\rightarrow [A][O_S][D]\} \\
  P_{Delegations} :=& \{D\rightarrow [hash\ hash]D,D\rightarrow [hash\ hash]\} \\
  P_{Voting} :=& \{V\rightarrow [hash\ float]V, V \rightarrow \varepsilon\}
\end{align}


\subsubsection*{zeige S(G) ist eindeutig}
\TODO[inline]{zeige S(G) ist eindeutig}


\subsection{Konsens}

\TODO[inline]{definiere $consens: L(S(G)) \rightarrow L(G)$}

% Die Idee hier ist, dass die transitive Hülle der Delegationen als
% Attribut während der Ableitung vererbt(inherited) wird. Die Votemenge
% wird hingegen als Attribut synthetisiert. Die Delegationen zusammen mit
% den Stimmen quantifizieren jede Option aus einer Optionsmenge und wählen
% eine Konsens-Option.

% Sei $\alpha,\beta$ und $o$ Wörter über dem Terminalalphabet. 
% 
% \[ \alpha, \beta, o \in T^* \] 
% 
% Sei $W_\alpha^\beta\subseteq K_G$ die Menge der Wörter, die $\alpha$ als Prefix und $\beta$ als Suffix besitzen. 
% 
% \[W_\alpha^\beta:=\{w|w=\alpha o\beta\land w\in K_G\}\]
% 
% 
% Falls $|W_\alpha^\beta|>1$ sowie $|\alpha| + |\beta| > 0$ gilt, folgt aus der Eindeutigkeit der Ableitung von $G$, dass es eine Regel $(R\rightarrow r)\in P$ exestieren muss, so dass $S \rightarrow^*_P \alpha R \beta$, sowie $\forall \alpha o \beta \in W_\alpha^\beta: R \rightarrow_P^* o$.
% 
% Sei $O_\alpha^\beta := \{o\in T^* | \alpha o \beta \in W_\alpha^\beta \}$, so reicht es $\alpha, \beta$ sowie jedes Element von $O_\alpha^\beta$ anzugeben, um die Menge zu beschreiben. 

% \subsubsection*{Algorithmus}

% Sei $O^R:=\{w| R \rightarrow^* w \}$. Wir definieren $O_r \subseteq O^R$ als die Teilmenge der Wörter von $O^R$, die durch die Regelausführung $(R\rightarrow r)\in P$ gebildet wurden.  \\
% 
% 
% \begin{algorithm}
%   
% \caption{$\phi: P(K_G) \rightarrow L(S(G))$}\label{euclid}
% \begin{algorithmic}[1]
% \Function{$\phi$}{$K_G$}
% \State\Return \Call{combine}{$K_G, S$}
% \EndFunction
% \\
% 
% \Function{combine}{$O^R, R$} 
% \If {$|O^R| = 1$}
%     \Return $o\in O^R$
% \Else
%   \State $W \gets \{\}$
%   \For{ $(R\rightarrow r)\in P$ }
%     \State $O_{r} \subseteq O^R$
%     \State $W\gets W\cup$ \Call{parse}{$O_r, r$}
%   \EndFor
%   \If {$|W|=1$}
%   \State\Return $w\in W$
%   \Else
%   \State\Return $[w_0 w_1 ... w_{|W|}]$
%   \EndIf
% \EndIf
% \EndFunction  
% \\
% 
% \Function{parse}{$O_r, r=s_0s_1...s_n$} 
%   \State $o\gets \epsilon$
%   \For{ $i\gets 0...n$ }
%     \If{$s_i\in T$}
%       \State$o \gets o \circ s_i$
%     \Else
%       \State$o \gets o \circ $ \Call{combine}{$O^s_i, s$}
%     \EndIf
%   \EndFor
% \EndFunction
% 
% \end{algorithmic}
% \end{algorithm}

% In Zeile (27) steht $O^s$ für die Menge der teilweörter von O, die an der Stelle von s, durch die regel R erzeugt werden.

% \TODO[inline]{Definition und Algorithmus für $O^s_i$ angeben.}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    MANIPULATION 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Transitionssystem}

% so dass alle Transaktionen des Objektes als Transaktionen eines contextfreien Wortes angesehen werden können. Die Transaktionsbedingungen können als Struktur des Wortes aufgefasst werden.
% Die Idee hinter der manipulation ist des es sich bei den Wörter um eine Persistente Datenstruktur handelt. Demnach können Optionen nur hinzu kommen, jedoch nicht gelöscht werden. Jeder Akteur kann Delegationen und Stimmen abgeben sowie
% die eigenen löschen, hat jedoch keine Macht über die Stimmen und
% Delegationen der Anderen.

Die Manipulation wird durch ein \textbf{initialisiertes Transitionssysthem $T=(M,I,\tau)$} beschrieben nach \cite{Glausch}.

$M$ ist die Zustandsmenge. $I\subseteq M$ ist die Anfangszustandsmenge und $\tau$ ist die Transformation von M sowie $\tau: M \rightarrow M$. Wir machen weiter die Einschränkung $|I|=1$.


% \subsection{Qualitätskritärien}
% 
% \begin{enumerate}
%   \item operationen wie $vote, delegate, addOption$ sind effizient in bezug auf Laufzeit und Speicherverbrauch.
%   \item Die Verifikation der Transaktion durch das Netzwerk soll möglichst effizient sein.
% \end{enumerate}

\subsubsection*{Wortteil}

Sei $G=(S,N,T,P)$ eine Grammatik und $w\in L(G)$, dann definieren wir ein Wortteil: 
\[ 
w_{i..j} := 
\begin{cases}
  (t_k)_{i\leq k \leq j}\text{ mit }t_k\in T &|\ i\leq j \\
  \varepsilon &|\ i>j
\end{cases}
\] 


\subsubsection*{Ablauf}
Eine Folge $(s_n)_{n\in\mathbb{N}}$ mit $s_n\in M$ ist ein Ablauf von T, wenn gilt:

\[ s_0 \in I \] 
\[ s_{i+1} = \tau(s_i) \] 

\subsubsection*{Zustände}

Sei $G = (N,T,S,P)$ eine rechtsreguläre Grammatik sowie
$S(G)=(N',T',S',P')$ die dazugehörige erweiterte Grammatik.

Ein Zustand ist eine Struktur der Form $(U, w) \in M$

U ist die Trägermenge der Struktur und besteht aus den Wörtern der Sprache $L(S(G))$:
\[U := L(S(G))\]

% $consens$ ist die für $L(S(G))$ definierte konsens Funktion:
$w\in U$ ist das derzeitige Wort

\subsubsection*{Aktualisierung}
Sei $A$ die Menge der Akteure, $L(S(G))$ eine Sprache zur gegebenen Grammatik $G$. Dann ist das Tupel $\delta = (a,w')$ mit $a\in A,\ w'\in L(S(G))$ eine Aktualisierung. Sei $\Delta \subseteq A\times L(S(G))$ die Menge aller aktueller Aktualisierungen.

Akteure können jederzeit die Aktualisierungsmenge erweitern: 
\[ \Delta' := \Delta \cup \{(a,w')\} \] 


\subsubsection*{Transformation}
Sei $\Delta \neq \emptyset$ 

\[
  \tau( w ) = 
  \begin{cases}
    w'  & \exists (a,w') \in \Delta \land \beta(a,w,w') = true \\
    w   & andernfalls 
  \end{cases}
\] 

Nach jeder Transformation wird die Aktualisierungsmenge ebenfalls aktualisiert, in dem die für die Transformation verwendete Aktualisierung entfernt wird. Wurde keine Aktualisierung verwendet, so sind alle Aktualisierungen invalide:

\[ 
  \Delta' = 
  \begin{cases}
    \Delta\setminus \{ (a, w' )\} & (a,w')\text{ wurde in der Transformation verwendet} \\
    \{\} & andernfalls
  \end{cases}
\] 


\subsubsection*{Validierung der Aktualisierung}
Um die Validität einer Transformation zu verifizieren, wird das derzeitige Wort $w$ zusammen mit dem auslösenden Akteur $a$ sowie seinem vorgeschlagenem Wort $w'$ betrachtet. Die Transformation ist valide, falls eines der folgenden Fälle zutrifft.
Es gilt also: $\beta(a,w,w') = true$ genau dann wenn:

\subsubsection*{Optionsmengen}
Eine Optionsmenge kann an jeder Position im Wort erzeugt oder erweitert werden, solange die erzeugte Kandidatenmenge durch $\phi^{-1}(w')$ valide bleibt, sowie die Bewertungen der Kandidaten $\phi^{-1}(w)$ nicht verändert werden. Die neu hinzukommenden Optionen dürfen keine Delegationen oder Stimmen enthalten, sowie noch nicht in der bisherigen Optionsmenge enthalten sein.

\subsubsection*{Erzeugen einer Optionsmenge}

Sei $S(G) = (T', N', S', P')$ eine erweiterte Grammatik. Sei weiter $O,S'\in N'$ sowie $v,o_1,o_2 \in T'^*$ und $0\leq i\leq j\leq n$ mit $i,j,k,n \in \mathbb{N}$

\begin{eqnarray}
  w &=& w_{0..n} \\
  w_{i..j} &=& \alpha o_1 \oplus [v] \\
  S' &\rightarrow^*& w_{0 .. (i-1)}\ O\ w_{(j+1) .. n}\\
  O &\rightarrow^*& w_{i..j} \\
  R &\rightarrow^*& o_1 \\
  R &\rightarrow^*& o_2 \\
  w' &=& w_{0..i-1}\ \alpha [o_1\oplus [v] o_2\oplus []][]\ w_{j+1 .. n}
\end{eqnarray}


Für $w$ hat $O$ folgende Struktur:
\begin{center}
\Tree [.O $\alpha$ [.R $o_1$ ] $\oplus$ $\lbrack$ [.V v ] $\rbrack$ [.O ... ] ]
\end{center}


Für $w'$ besitzt O folgende Struktur:
\begin{center}
\Tree [.O $\alpha$ [.R $\lbrack$ [.O $o_1$ $\oplus$ $\lbrack$ [.V v ]  $\rbrack$ [.O $o_2$ $\oplus$ $\lbrack$ [.V $\epsilon$ ] $\rbrack$ ] ] $\rbrack$ $\lbrack$ [.D $\epsilon$ ] $\rbrack$ ] $\oplus$ $\lbrack$ $\rbrack$ [.O ... ] ]
\end{center}

Dabei muss $o_2$ frei von Delegationen und Stimmen sein, sowie $o_2$ muss relativ zu $o_1$ neu sein.


\subsubsection*{Erweitern einer Optionsmenge}
 
Sei $o,d,r \in T'^*$ sowie $R,O_R \in N'$

\begin{eqnarray}
  w &=& w_{0..n} \\
  w_{i..j} &=& \alpha[o][d] \\
  R   & \rightarrow ^*& w_{i..j}\\
  O_R & \rightarrow_P^*& o\\
  O_R & \rightarrow ^* & r\\
  w' & = & w_{0..(i-1)}\ \alpha[o r\oplus []][d]\ w_{(j+1)..n} 
\end{eqnarray}

$r$ muss dabei Delegations- und Stimmfrei sein sowie neu:
\[ \phi^{-1}(w) \cap \phi^{-1}(w_{0..i-1}\ \alpha[r\oplus []][d]\ w_{j+1..n}) = \emptyset \] 


\subsubsection*{Hinzufügen einer Stimme}

Sei $w_{i..j} = r\oplus [v]$

Dann ist $w' = w_{0 .. i-1}\ r \oplus [v[h n]]\ w_{j+1 .. n}$ mit $0\leq n\leq 1$ eine valide Substitution.

\subsubsection*{Löschen einer Stimme}

Sei $a\in A, v,v'\in T'^*$

\begin{eqnarray}
  w &=& w_{0..n} \\
  w_{i..j}&=& r\oplus [v [an] v'] \\
  w' &=& w_{0..(i-1)} r\oplus [vv'] w_{(j+1)..n}
\end{eqnarray}


\subsubsection*{Hinzufügen einer Delegation}
Da die Reihenfolge der Delegationen wichtig ist, für die Auflösung konkurierender Delegationen, daher ist das Hinzufügen einer Delegation an jeder Stelle in einer Delegationsmenge möglich.

Sei $o,d_i \in T'^*$ sowie $a'\in A$ und $a'\neq a$

\begin{eqnarray}
  w &=& w_{0..n} \\
  w_{i..j} &=& [o][d_1 .. d_n] \\
  &&k,n\in \mathbb{N} \land k\leq n \\
  d_k &=& [hash1_k\ hash2_k] \\ 
  w' &=& w_{0 .. (i-1)}\ [o][d_1 .. d_{k-1} [a\ a'] d_k .. d_n ]\ w_{(j+1) .. n}
\end{eqnarray}

\subsubsection*{Löschen einer Delegation}

Sei $o,d_i \in T'^*$ sowie $a'\in A$ und $a'\neq a$

\begin{eqnarray}
  w &=& w_{0..n} \\
  d_k &=& [a\ a'] \\
  w_{i..j} &=& [o][d_1 .. d_{k} .. d_n ] \\
  w' &=& w_{0 .. (i-1)}\ [o][d_1 .. d_{k-1} d_{k+1} .. d_n ]\ w_{(j+1) .. n}
\end{eqnarray}

\subsection{Delegationsprogrammierung}
Akteure können ihre Stimme nicht nur an externe Akteure delegieren, sondern auch an Contracts, welche in einer autonomen Weise abstimmen und so die Interessen der Akteure automatisch verfolgen. 

\subsubsection*{Beispiele}

Sei $G=(T,N,P,S)$ eine rechtsreguläre Grammatik mit:
\[ T:=\{ a, b, c \}, N:=\{S\}, P:= \{S\rightarrow aS\ |\ bS\ |\ cS\ |\ \varepsilon \} \] 

Ein Delegationsprogramm kann mit dem Interesse entwickelt werden, nur für Kandidaten der kontextsensitiven Sprache $L = \{ a^nb^nc^n\ |\ n\in N\}$ zu stimmen so, dass falls die Mehrheit der Akteure ihm seine Stimme delegieren, der Konsens-Kandidat ebenfalls ein Element der Sprache $L$ sein wird. Auf diese weise lassen sich von den Akteuren komplexe Programme erstellen um die Kandidatenmenge agil und autonom zu bewerten.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      IMPLEMENTATIONSPLAN
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Umfang der Arbeit}

\subsection*{Konzeptuell}
\begin{itemize}
  \item Die Punkte unter Aufgaben (TODO's) werden ausformuliert.
  \item Dieses Papier wird überarbeitet und strukturiert. Es wird mit anschaulichen Beispielen, Erklärungen, Beweisen,  Quellen sowie Verweisen grundlegender Konzepte ergänzt. Solche Konzepte sind: 
    \begin{itemize}
      \item reguläre/ kontextfreie Grammatik, Normalformen, Ableitungen, Eindeutigkeit
      \item Algebraisches-Transitionssystem
      \item $\Sigma$-Strukturen/-Signaturen
      \item Turing-Vollständigkeit
      \item asymmetrische Verschlüsselung
    \end{itemize}
  \item Die Punkte unter Aussicht werden diskutiert, jedoch weder implementiert, noch im Umfang der Anwendung auf die regulären Grammatiken konzipiert.
\end{itemize}


\subsection*{Implementation}
\begin{itemize}
  \item Eine Zentralisierte Version der $L(S(G))$-Sprache sowie des Transitionssystem wird implementiert.
  \begin{itemize}
    \item JISON\footnote{http://jison.org/}, eine javascript Portierung des Bison\footnote{http://www.gnu.org/software/bison/}/Flex\footnote{http://flex.sourceforge.net/} LALR(1) Parser Generators wird so erweitert, dass bei Eingabe einer beliebigen regulären Grammatik $G$ im bison Format\footnote{http://dinosaur.compilertools.net/bison/bison\_6.html} dieser einen Parser erzeugt welcher Wörter aus der $L(S(G))$ Sprache als Eingabe bekommt und ein öffentliches Transitionssystem erzeugt.
    \item Ein Initialisierungs-Script, welches aus einem Wort der $L(G)$ Sprache und einer Besitzverteilung gegeben als $\{(a,n)| a\in\ 20byteHexString \land n\in \mathbb{N} \}$ ein valides initiales Wort in der $L(S(G))$ Sprache erzeugt.
    \item Akteure können durch eine Webseite in die Transaktionshistorie einsehen, sowie das Wort valide manipulieren.
    \item Eine Client-seitige asymmetrische Verschlüsselung validiert die Transaktionen der Akteure.
    \item Die Konsens-Funktion wird ebenfalls Implementiert und erzeugt zu jedem Stand einen öffentlich verfügbaren Konsens-Kandidaten.
  \end{itemize}
  \item Einige anschauliche Beispiele regulärer Sprachen mit beispielhaften Delegationsprogrammen werden implementiert und demonstriert.
\end{itemize}

\subsection*{Todos}

\listoftodos[Aufgaben]



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%       Aussicht
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Aussicht}

\subsection*{Anwendung auf kontextfreie Grammatiken}

% Die validität einer Sprache ist jedoch meist nicht nur aus der kontextfreien syntax zu schließen. So werden namensresolutionen und typisierung beim compilieren in späteren schritten auf eine kontext sensitive weise überprüft. Dies
% Syntax von Programmiersprachen sind nicht kontextfrei, sondern Kontextsensitiv \cite{Otto}

% Validitätskritärien: Objekt hängt von keiner Grammatik ab, sondern von einer Mänge von Validitätskritärien von denen die Grammatik eine sein kann. Die validitätskritärien schränken den Raum der Kandidaten automatisch ein. Die ausgewählten Kandidaten der Kandidatenmenge sind somit alle valide. Ihre bewertung sind präferrenzen der akteure.
% \[ K \subseteq VK \subseteq \bigcap_{v\in V} v \] 

\subsection*{Dezentralisierung}

\subsection*{Anonymisierung}

\subsection*{Manipulation der Besitzverteilung}
\subsection*{Manipulation der Grammatik}


% \begin{itemize}
%   \item änderungen der Grammatik berücksichtigen
% \end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      QUELLEN
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage
\section{Quellen}


\bibliography{library}

\bibliographystyle{alpha}

\end{document}

