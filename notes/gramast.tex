\documentclass[]{article}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript

% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[utf8x]{inputenc}
\else % if luatex or xelatex
  \usepackage{fontspec}
  \ifxetex
    \usepackage{xltxtra,xunicode}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{€}
\fi
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            pdfauthor={},
            pdftitle={},
            colorlinks=true,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

% Treeview
\usepackage{tikz}
\usepackage{tikz-qtree}

% Graphviz
\usepackage{graphvizzz}

% Source Code so found here: http://en.wikibooks.org/wiki/LaTeX/Source_Code_Listings
\usepackage{listings}

% Definitionen
\usepackage{amsthm}

% Algorithmen
\usepackage{algpseudocode}
\usepackage{algorithm}

%todo 
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}

\usepackage{xargs}                      % Use more than one optional parameter in a new commands

\newcommandx{\TODO}[2][1=]{\todo[linecolor=none,backgroundcolor=gray!25,bordercolor=none,#1]{\textbf{TODO: }#2}}



\newtheorem{mydef}{Definition}


\author{}
\date{}

\begin{document}


\tableofcontents


\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      EINLEITUNG
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Einleitung}

% Es geht um Akteure, Besitz, Bewertung
Im Internet werden zunehmend Inhalte kollaborativ erzeugt. 
Dabei entsteht ein Inhalt durch Beiträge einzelner \textbf{Akteure}.
Zentral ist die Frage nach dem \textbf{Besitz} des Inhaltes sowie die \textbf{Bewertung} der einzelnen Beiträge durch die Besitzer und damit ihren Anteil am \textbf{Gesamtergebnis}. 


% Problem: der Verwaltung( Manipulation ) und der besitzallokation

In dieser Arbeit möchte ich eine Meta-Programmiersprache
\textbf{$S(G)$} für eine beliebige linksreguläre Grammatik
$G$ herrausarbeiten, die die verteilte Steuerung von Inhalten ermöglichen soll, die eine reguläre Grammatik besitzen.



Hierfür werden in (1) zwei Funktion angegeben. Eine erweitert eine
gegebene kontextfreie Grammatik $G$ zu einer $S(G)$, eine Konsensfunktion erzeugt aus einem Wort der Sprache $L(S(G))$, ein Wort in der ursprünglichen Sprache
$L(G)$. Manipulationen eines Wortes einer $L(S(G))$-Sprache sind bedingungen
unterworfen, die in (2) angegeben sind.


\newpage




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      VERIFIZIERUNG 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Dezentrale Verifizierung}

Das auf dem Bitcoin-Protokoll aufbauende Ethereum \cite{Wood2014}, beschreibt ein Protokoll in einem Netzwerk zur dezentralen Verifizierung von turing-vollständigen Programmausführungen. 
Es stellt einen gebildeten Konsens von Programmen mit Aktuellen Zuständen bereit. 
Neue Inhalte wie neue Programme oder neue Interaktionen von Akteuren mit Programmen werden nach einer veröffentlichung und Validierung der Ausführung durch das Netzwerk mit dem neu berechnetem Zustand in den Konsens aufgenommen.

Akteure werden durch ein 20-byte Adresse identifiziert. Ihre Interaktion mit dem Netzwerk ist durch ein asymmetrisches Kryptosystem gesichtert.

Das Netzwerk finanziert sich durch die Validierung der Programme. Für jeden Berrechnungsschritt wird ein kleiner Betrag vom Interagierenden Akteur erhoben. Ist nicht genügend Wert verfügbar, terminiert die Transaktion und wird vom Netzwerk abgelehnt. So wird auch das Halteproblem umgangen.

Ein Beispiel für ein Programm währe eine dezentrale Währung, wie sie derzeit vom Bitcoin Protokoll repräsentiert wird (Quelle \cite{Butterin2014}):

% Speicher & Rechenleistung = Geld


% ! Akteure = Programme | Benutzer

\begin{lstlisting}
  from = msg.sender
  to = msg.data[0]
  value = msg.data[1]

  if self.storage[from] >= value:
  self.storage[from] = self.storage[from] - value
  self.storage[to] = self.storage[to] + value
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   GETEILTES OBJEKT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Digitale Geteiltes Objekt}

% Inhalte können referenziert werden, doch wer stellt die referenz bereit?

% Betrachtung von Sprachen die contextfrei interpretiert werden.
Digitale Geteilte Objekte müssen in digitaler repräsentation vorliegen, sowie für die Anteilseigner in verschlüsselter oder unverschlüsselter form zugänglich sein.

Beispiele währen: 

\begin{itemize}
  \item medialen Inhalte wie Bilder, Texte oder Videos
  \item Programme und contextuelle Angaben wie deren Compiler oder die Architektur
  \item Besitzrepräsentation wie Bitcoin Anteile oder Aktien
\end{itemize}


% um alle inhalte abzudecken reicht es die abzudecken, die eine eine repräsentation als worte einer contextfreien sprache besitzen
Sie können einerseits in direkter Form, oder als Referenz unter angabe einer $URI$ angegeben werden.

Andererseits können digitale geteilte Objekte dynamische Ihnalte repräsentieren, welche eine Syntax besitzen und durch ein Compiler Interpretiert werden können. Da URI's durch reguläre Sprachen ($REG$) konstruiert werden können und $L(REG) \subsetneq L(CFG)$ ist. Reicht es zur betrachtung aller digitaler Objekte 
solche zu betrachten, die durch eine $CFG$ Syntax besitzen, oder durch eine Solche referenziert werden können.

% \begin{mydef}
Ein \textbf{geteiltes digitales Objekt} ist ein Tupel $O_G=(A, K, w, rate, consens)$ bestehend aus:

\begin{enumerate}
\item Eine endliche Menge von Akteuren $A$
\item Eine eindeutige \textbf{Besitzverteilung} von Akteuren zum Objekt
  \[w: A \rightarrow \mathbb{N}\]
\item eine endliche Menge von validen Kandidaten mit mindestes einem Element 
  \[K_G \subseteq \{w|S \rightarrow^*_P w \land w\in T^* \} \land |K_G| \geq 1\] 
\item eine Bewertung der Kandidaten durch die Akteure. 
  \[rate: A\times K \rightarrow [0,1]\]
\item einer Konsensfunktion
  \[consens: A\times K\times w \times rate \rightarrow L(G)\] 
\end{enumerate}

Sei $\mathbf{SOBJ_G}$ die Menge aller geteilten Objekte in der Grammatik $G$ sowie 
 $\mathbf{KAND_G}:= \{ K_G | K_G \subseteq L(G) \}$ die Menge aller möglichen Kandidatenmengen.
% \end{mydef}


\subsection {Repräsentation}

\subsubsection {Akteure}

% Motivation

% Inhalt besitzt einen Wert, Akteure wollen ihren Besitz Maximieren
Da ein Geteiltes Objekt auch Werte in Form einer Kryptowährung wie Bitcoin beinhalten kann, strategische wertvolle Attribute in einem Netzwerk besitzt, wie Reputation oder Namensrechte, geschlossene Informationen beinhaltet auf die nur die Eigentümer zugreifen können oder Gewinnüberschüsse an die Besitzer ausschüttet, besitzt das Objekt und somit auch seine Anteile auf einem freien Markt einen reellen und spekulativen Wert. Somit könenn wir davon ausgehen, dass es im Interesse jedes rationalen Akteurs ist, seinen Besitzanteil zu maximieren. (\textbf{AMAX})

% Vergrößerung durch strategischen tausch gegen andere Werteträger oder durch vorschlagen von Optionen


\subsubsection{Besitzverteilung}

%Aktienmodell

Die Besitzverteilung wird änlich dem Aktienmarkt Modelliert. Dabei hat ein geteiltes Objekt eine bestimmte Anzahl an Teilen (geschrieben $|O| \in \mathbb{N}$), die unter den Akteuren aufgeteilt sind. 
\[ |O| := \sum_{a \in A} w(a) \] 
% todo: warum?

% Besitz = Bestimmung
Der Besitz eines Objekts $O$ wird durch das Recht definiert, auf dieses zugreifen zu können und es Kontrollieren zu können\cite{Waldron2004}. Besitzen mehrere Akteure ein Objekt, so gibt der Anteil am Objekt an, zu welcher gewichtung jeder einzelne Akteur über das Objekt mit bestimmen kann.

Eine Konsensfunktion entscheidet über die Ausführung der Kontrolle. Dabei kann eine Zustimmung von $\frac{1}{2}|O|$ eine Ausführung bedingen. Man spricht von einer \textbf{majorität}. Eine Zustimmung von $\frac{2}{3}|O|$ heißt \textbf{super majorität}.


% Intuitiev sollte der initialle Besitzer eines Inhalts sein Schöpfer sein. Dieser kann sein Besitz bei einer einigung an dritte abgeben, oder der Allgemeinheit überlassen. Bei einem Kollaborativ entstandenem Inhalt, bewerten die Besitzer die Beiträge


% Die Funktion $w_O: A \rightarrow \mathbb{N}$ gibt den Anteil von O an, der im Besitz von einem Akteur ist. 

% Gilt $share_O(a) > 0$, so nennt man $a$ auch ein \textbf{Member} von $O$.
% 
% $M_O \subseteq A$ ist die Menge aller Member von $O$.


\subsection{Kandidaten}

Eine wichtige Frage ist, ob alle syntaktisch validen Kandidaten zugelassen werden, oder nur semantisch valide. Falls nur semantisch valide zugelassen werden stellt sich die Frage wo geschieht diese Validierung.

\subsection {Transaktionen}

Transaktionen sind Manipulationen des derzeitigen Zustandes des Objektes. Sie werden \textbf{immer} von einem Akteur $a$ ausgelöst und besitzen die Form $(a, O')$. $O'$ ist dabei das manipulierte geteilte Objekt.

Wir betrachten vorerst nur die Manipulation der Kandidatenmenge $K$ sowie der Kandidatenbewertung $rate$. 



% Hierzu wird die Bedingungen gestellt, dass bestehende Kandidaten nicht entfernt werden ($K \subseteq K'$).


\subsection{Konsens}


% Die Idee hier ist, dass die transitive Hülle der Delegationen als
% Attribut während der Ableitung vererbt(inherited) wird. Die Votemenge
% wird hingegen als Attribut synthetisiert. Die Delegationen zusammen mit
% den Stimmen quantifizieren jede Option aus einer Optionsmenge und wählen
% eine Konsens-Option.
% 
% 
% 
% \begin{itemize}
% \itemsep1pt\parskip0pt\parsep0pt
% \item
%   zirkuläre delegationen
% \item
%   implekation von Arrow's Theorem auf strategisches voten
% \end{itemize}


\subsection {Bewertung}

%todo: bewertung kann kontextfrei sein -> an die spracherweiterung binden? 
%todo: für kontextsensitive bewertungen gibt es 1) deligationen und 2) direkte kandidatenbewertungen

\subsection {Qualitätskriterien}

Für die Implementation ist auf folgende Qualitätskriterien zu achten:

\begin{description} 
  \item[\textbf{RESMIN:}]\hfill \\
    Es sind möglichst wenig Ressourcen (Speicher und Rechenleistung) vom Ethereum-Netzwerk notwendig, um Transaktionen zu validieren.
  \item[\textbf{INTMIN:}]\hfill \\
    Eine Akteur soll möglichst wenig Interaktionen benötigen, um auf eine gewünschte, von ihm erreichbare Manipulation zu kommen.
\end{description}

% 
%   * die Kandidatenmenge muss komprimiert werden, damit deren Speicherung möglichst wenig Speicher in anspruch nimmt.
%   * die validierung der manipulation muss eine kleine laufzeit haben.

% 

% es ist einfach für einen Akteur eine Bewertung über viele Kandidaten abzugeben.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     IMPLEMENTATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Optimierung}

\subsection{Optimierung der Kandidatenmenge}
Die Idee hinter der Optimierung ist nah am Parsebaum der Grammatik zu arbeiten und die Grammatik so zu erweitern, dass die Wöterer der Kandidatenmenge in einem Wort der erweiterten Grammatik codiert werden können. Redundant auftauchende Stellen zwischen den Wörtern werden zusammengefasst. An jedem Ableitungsschrit wird eine Mehrdeutigkeit zugelassen. Die Kandidatenmenge ergibt sich durch die verschiedenen Kombination der mehrdeutigen Ableitung.

Dazu muss es eine Grammatikerweiterung $S: CFG \rightarrow CFG$ gefunden werden.
Um zu zeigen, dass es sich bei $S$ um die gesuchte Funktion handelt, müss die Existenz der Funktionen $\phi: KAND_G \rightarrow L(S(G))$ und $\phi^{-1}: L(S(G)) \rightarrow KAND_G$ gezeigt werden, sowie folgende Bedingungne erfüllt sein:

\begin{align}
 K_G &\subseteq \phi\circ\phi^{-1}(K_G) \\
 |\phi(K_G)| &\lesssim \sum_{k\in K_G} |k|
\end{align}

In Bedingung (1) ist es zulässig, dass neue Kandidaten hinzu kommen, solange sie valide Wörter in der $L(G)$ Sprache bilden. 
\TODO[inline]{diskutieren ob hier nicht die stärkere bedingung $\phi\circ\phi^{-1} = id_{KAND_G}$ besser währe}
In Bedingung (2) werden Edge-Cases ausgeschloßen, die nur bei kleinen diversen lösungen auftauchen können. (z.B.: $\{a\ b\}$)


% so dass alle Transaktionen des Objektes als Transaktionen eines contextfreien Wortes angesehen werden können. Die Transaktionsbedingungen können als Struktur des Wortes aufgefasst werden.

% Sei $\Sigma$ eine Signatur der Form $(w,0)$. Sei $A$ eine dazu passende Algebra der Form $(L(S(G)),w)$. Der derzeitige Ansatz ist ein Isomorphismus $\phi$ zu funden


% example
% \Tree [.S [.NP LaTeX ] [.VP [.V is ] [.NP fun ] ] ]

% Um den Konsensprozess effizienter zu gestalten, können Akteure ihre Stimme für bestimmte Bereiche der Sprache an andere Akteure Delegieren.

% \subsubsection{Programmiersprache}
% Zur eindeutigen bestimmung der Syntax einer Programmiersprache reicht es, eine eindeutige CFG $G$ anzugeben. Anders gibt es auch zu jeder Syntax einer Programmiersprache auch eine CFG. Ein Programm ist ein Wort aus der Sprache $w\in L(G)$. 
% Ausgeführt wird es durch die Interpretation eines Compilers $[\![w]\!]_\mathcal{C}$.

% Die validität einer Sprache ist jedoch meist nicht nur aus der kontextfreien syntax zu schließen. So werden namensresolutionen und typisierung beim compilieren in späteren schritten auf eine kontext sensitive weise überprüft. Dies
% Syntax von Programmiersprachen sind nicht kontextfrei, sondern Kontextsensitiv \cite{Otto}

% \subsection{Sprach-Erweiterung}

% Abhängig von einer gegebenen Programmiersprache $G=(N,T,S,P)$ soll eine Erweiterte Programmiersprache $L(S(G))$ konstruiert werden. Die Wörter der neuen Sprache repräsentieren ein geteiltes Programm $O$ und besitzen folgende Informationen:


% Zu dem wird eine Compilierfunktion gesucht, die Wörter der $L(SCFG)$ Sprache, wörter der Ursprünglichen Sprache $L(G)$ zuweist. 
% $$ consens_O: L(SCFG) \rightarrow L(G)$$

% Zusätzlich zur Sprache wird eine Funktion gesucht, die aus der Besitzverteilung, der Programmme und deren Bewertungen eine Gruppenbewertung der Programme erstellt. Das Programm mit der maximalen Gruppenbewertung wird als \textbf{Konsensprogramm} angesehen. 
% $$ consens_O: A\times (A,\mathbb{N})\times P \times (A,P,[0,1]) \rightarrow P $$

% Die gesuchte Sprache $L(SCFG)$ kann folglich auch durch eine CFG bestimmt werden. Die Interpretation eines Wortes aus der Sprache 

% \subsection{Qualitätskritärien}
% 
% \begin{enumerate}
%   \item die wörter der Sprache $L(SCFG)$ sind möglichst klein
%   \item es ist einfach Optionen zu Bewerten: Die Anzahl der transitionen ist möglichst klein, um auf ein gewünschtes Bewertungsprofil zu kommen.
%     
%     Sei $a\in A$ ein Akteur, sei $X_i\subseteq P\times [0,1]$ die derzeitige Bewertung der Programme von $a$ und sei $X_j\subseteq P\times [0,1]$ die gewünschte Bewertung. Sei $t$ eine von $a$ gültige Transformation, so dass $X_k \rightarrow_{t} X_{k+1}$ und sei T die Menge der von a gültigen Transformationen. Die Bewertung ist einfach, wenn für $X_i \rightarrow_{ T }^n X_j$ n möglichst minimal ist.
% \end{enumerate}


% \subsection{Bewertung}
% Diese werden entweder \textbf{direkt}, also vom Akteur selber, oder \textbf{indirekt} also durch eine Delegation an einen anderen Akteur angegeben.
% \subsubsection{Intuition}
% 
% 
% Eine \textbf{Optionsmenge}, oder Kurz eine \textbf{Option}, können wir
% als eine Menge von Kandidaten modellieren, von denen jeder ein Gültiger
% Kandidat für eine Spezifikation ist. Ist eine \textbf{Option} im Besitz
% mehrerer \textbf{Akteure}, so müssen die Akteure einen Weg finden über
% die Option zu entscheiden. Dies bedeutet durch einen Konsensprozess sich
% auf einen kandidaten Einigen.
% 
% \begin{verbatim}
% Optionsmengen können als Mengen von Aussagen angesehen werden. Eine Ableitung durch eine Konsesnfunktion vielleicht durch eine Logische Ableitung einer Akteurgruppe.
% 
% Vielleicht ist das Konzept, welches ich Modelliere eine contextsensitive Sprache, da Optionen nur im Kontext ihre gültigkeit besitzen.
% 
% was ist mit der 'löschungs' Regel, sie ist nicht Teil der Kontextsensitiven Grammatik
% 
% \end{verbatim}

\subsection{Grammatikerweiterung S}

Sei $G = (N,T,S,P)$ eine eindeutige contextfreie Grammatik.

Eine Kompression der Kandidatenmenge wird definiert als:
\\$S(G) := G' = (N', T', S, P')$, mit:

$N' := N \cup \{ O \}\ mit\ O \notin N$

$T' := T \cup \{[ , ] \}\ mit\ [,] \notin T$

% \textbf{number} stellt eine ganzzahlige Nummer dar. \textbf{float}
% stellt eine fließkommazahl dar. \textbf{hash} ist ein identifikatior für
% einen akteur, hier ein 20 bytes hex string.

$P' := P
\cup P_{Options} 
% \cup P_{Start} 
% \cup P_{Delegations} 
% \cup P_{Voting} 
% \cup P_{Acteurs}
$

$P_{Options} := \{R \rightarrow [O], O \rightarrow r O \ \vert\ R\rightarrow r\in P$
mit $r\in (N\cup T)^*\}\cup\{ O \rightarrow \varepsilon \}$

% $P_{Start} := \{S'\rightarrow [A]S\}$

% $P_{Delegations} := \{D\rightarrow [hash\ hash]D,D\rightarrow [hash\ hash]\}$

% $P_{Voting} := \{V\rightarrow [hash\ float]V, V \rightarrow \varepsilon\}$

% $P_{Acteurs} := \{A\rightarrow[hash\ number]A,A\rightarrow \varepsilon\}$

% \paragraph{zu zeigen}
% 
% \begin{itemize}
% \itemsep1pt\parskip0pt\parsep0pt
% \item
%   eindeutigkeit der SCFG
% \end{itemize}

\subsection{Morphismus}
% Sei $\alpha,\beta$ und $o$ Wörter über dem Terminalalphabet. 
% 
% \[ \alpha, \beta, o \in T^* \] 
% 
% Sei $W_\alpha^\beta\subseteq K_G$ die Menge der Wörter, die $\alpha$ als Prefix und $\beta$ als Suffix besitzen. 
% 
% \[W_\alpha^\beta:=\{w|w=\alpha o\beta\land w\in K_G\}\]
% 
% 
% Falls $|W_\alpha^\beta|>1$ sowie $|\alpha| + |\beta| > 0$ gilt, folgt aus der Eindeutigkeit der Ableitung von $G$, dass es eine Regel $(R\rightarrow r)\in P$ exestieren muss, so dass $S \rightarrow^*_P \alpha R \beta$, sowie $\forall \alpha o \beta \in W_\alpha^\beta: R \rightarrow_P^* o$.
% 
% Sei $O_\alpha^\beta := \{o\in T^* | \alpha o \beta \in W_\alpha^\beta \}$, so reicht es $\alpha, \beta$ sowie jedes Element von $O_\alpha^\beta$ anzugeben, um die Menge zu beschreiben. 

\newpage
\subsubsection*{Algorithmus}

Sei $O^R:=\{w| R \rightarrow^* w \}$. Wir definieren $O_r \subseteq O^R$ als die Teilmenge der Wörter von $O^R$, die durch die Regelausführung $(R\rightarrow r)\in P$ gebildet wurden.  \\


\begin{algorithm}
  
\caption{$\phi: KAND_G \rightarrow L(S(G))$}\label{euclid}
\begin{algorithmic}[1]
\Function{$\phi$}{$K_G$}
\State\Return \Call{combine}{$K_G, S$}
\EndFunction
\\

\Function{combine}{$O^R, R$} 
\If {$|O^R| = 1$}
    \Return $o\in O^R$
\Else
  \State $W \gets \{\}$
  \For{ $(R\rightarrow r)\in P$ }
    \State $O_{r} \subseteq O^R$
    \State $W\gets W\cup$ \Call{parse}{$O_r, r$}
  \EndFor
  \If {$|W|=1$}
  \State\Return $w\in W$
  \Else
  \State\Return $[w_0 w_1 ... w_{|W|}]$
  \EndIf
\EndIf
\EndFunction  
\\

\Function{parse}{$O_r, r=s_0s_1...s_n$} 
  \State $o\gets \epsilon$
  \For{ $i\gets 0...n$ }
    \If{$s_i\in T$}
      \State$o \gets o \circ s_i$
    \Else
      \State$o \gets o \circ $ \Call{combine}{$O^s_i, s$}
    \EndIf
  \EndFor
\EndFunction

\end{algorithmic}
\end{algorithm}

In Zeile (27) steht $O^s$ für die Menge der teilweörter von O, die an der Stelle von s, durch die regel R erzeugt werden.

\TODO[inline]{$\phi^{-1}$ Definieren}
\TODO[inline]{Definition und Algorithmus für $O^s_i$ angeben.}
\TODO[inline]{Beweisen das der Algorithmus die Kritärien Erfüllt}



\subsection{Abstimmungen}
Meine erste Idee war es. Abstimmungen an Optionen zu binden. Dadurch würde sich ein Präferenzprofiel für einen Akteur ergeben, bei dem der Akteur die Kandidaten am besten Bewertet, bei denen die meisten Optionen enthalten sind, für die er sich ausgesprochen hat. Ein solchens vorgehen ist zwar bei kontextfreien inhalten sinvoll, da jedoch durch Programme ein kontextsensitiver Inhalt dargestellt ist, muss ein beliebiges Präferenzprofiel über der Kanddatenmenge möglich sein, dieses ist jedoch nicht möglich, wenn die Abstimmungen an Optionen gebungen werdnen.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    MANIPULATION 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{2. Manipulation}

Die Idee hinter der manipulation ist des es sich bei den Wörter um eine Persistente Datenstruktur handelt. Demnach können Optionen nur hinzu kommen, jedoch nicht gelöscht werden. Jeder Akteur kann Delegationen und Stimmen abgeben sowie
die eigenen löschen, hat jedoch keine Macht über die Stimmen und
Delegationen der Anderen.

Die Manipulation wird durch ein \textbf{initialisiertes Transitionssysthem $T$}
beschrieben.

Sei $G = (N,T,S,P)$ eine eindeutige Grammatik sowie
$G'=S(G)=(N',T',S',P')$ die dazugehörige SCFG.


\subsection{Qualitätskritärien}

\begin{enumerate}
  \item operationen wie $vote, delegate, addOption$ sind effizient in bezug auf Laufzeit und Speicherverbrauch.
  \item Die Verifikation der Transaktion durch das Netzwerk soll möglichst effizient sein.
\end{enumerate}

\subsection{States}

Ein Zustand der  ist eine Struktur der form $(U, compile, w)$

U ist das Universum der Struktur und wird definiert durch:
\[U=\{w\vert S'\rightarrow_p^* w \land w\in T'^*\}\]

$compile$ ist die in (1.2) definierte Funktion der Form:
$compile: L(G') \rightarrow L(G)$

$w\in U$ ist das derzeitige Wort

\subsection{Transitionen}

\TODO[inline]{von delegationen und abstimmungen befreien}

Bei der Interaktion eines Programms, ist der Akteur bekannt und wird
durch ein Public Key ausgewiesen. Der Akteur kann in einem
Interaktionsschritt das derzeitige Wort altuallisieren, wenn es
bestimmte Bedingungen erfüllt. Eine Interaktion ist also ein Tupel
$(h,w')$ so, dass $h$ der Public Key des Akteurs ist, sowie $w'$ das
neue Wort.

% Die Transitionen können zu den Auslösenden Akteuren ebenfalls durch eine Kontextuelle Grammatik beschrieben werden.
\subsubsection*{Erzeugen einer Optionsmenge}


% \Tree [.S [.NP LaTeX ] [.VP [.V is ] [.NP fun ] ] ]
% \begin{center}
% \Tree [.O $\alpha$ [.R $o_1$ ] $\beta$ $\oplus$ $\lbrack$ [.V v ] $\rbrack$ ]
% \end{center}
% 
% \begin{center}
% \Tree [.O $\alpha$ [.R $\lbrack$ [.O $o_1$ $\oplus$ $\lbrack$ [.V v ]  $\rbrack$ [.O $o_2$ $\oplus$ $\lbrack$ $\rbrack$ ] ] $\rbrack$ $\lbrack$ [.D $\epsilon$ ] $\rbrack$ ] $\beta$ $\oplus$ $\lbrack$ $\rbrack$ ]
% \end{center}


Sei $\alpha,\beta,o_1,o_2 \in T'^*$ sowie $R\in N$ und
$V \rightarrow_P^* v$ Sei $w=\alpha o_1 \beta \oplus [v]$ Sei weiter
$R\rightarrow_p^* o_1$ sowie $R\rightarrow_p^* o_2$ Dann ist
$w:=\alpha [o_1\oplus [v] o_2\oplus []][]\beta$ eine valide Transition.

\subsubsection*{Erweitern einer Optionsmenge}

Sei $w=\alpha[o]\beta \land S'\rightarrow_P^* \alpha R \beta$ mit
$O\rightarrow_P^* o, o\in T'^*, R\in N$ Dann ist
$w:=\alpha[o r\oplus []]\beta$ mit $R \rightarrow_P^* r, r\in T'^*$ eine
valide Transition.

\subsubsection*{Hinzufügen einer Stimme}

Sei $w=\alpha r\oplus [v]\beta$

Dann ist $w:=\alpha r \oplus [v[h n]]\beta$ mit $n=float$ eine valide
Transition.

\subsubsection*{Löschen einer Stimme}

Sei $w=\alpha [hn]\beta$

Dann ist $w:=\alpha\beta$ mit eine valide Transition.

\subsubsection*{Hinzufügen einer Delegation}
Analog der Stimme

\subsubsection*{Löschen einer Delegation}
Analog der Stimme

\subsubsection*{Transaktion} %Überweisung

\subsection{Delegationsprogrammierung}

\paragraph{Context Delegation}
\paragraph{A/B Tester}

\subsection{zu untersuchen}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  wie werden neue anteile vergeben
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      IMPLEMENTATIONSPLAN
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Umfang der Arbeit}

\subsection*{Konzeptuell}
\begin{itemize}
  \item Überarbeitung der Spracherweiterung
    \begin{itemize}
      \item macht eine Spracherweiterung überhaupt sinn?
    \end{itemize}
  \item Die Manipulation der Besitzverteilung $w$ sowie der Grammatik $G$ eines Objektes O wird in Aussicht gestellt. Ihre untersuchung ist jedoch nicht gegenstand dieser Arbeit.
\end{itemize}


\subsection*{Implementation}
\begin{itemize}
  \item Eine Zentralisierte Version der $L(S(G))$-Sprache sowie des Transitionsysthems wird implementiert 
  \begin{itemize}
    \item JISON, ein Bison/Flex ähnlicher javascript LALR(1) parser generator wird so erweitert, dass bei Eingabe einer beliebigen Grammatik $G$ dieser einen Parser erzeugt welcher Wörter aus der $L(S(G))$ Sprache als Eingabe bekommt und ein öffentliches Transitionsysthem erzeugt.
    \item Ein Initialscript, welches aus einem Wort der $L(G)$ Sprache und einer Besitzgewichtung gegeben als $\{(a,n)| a\in 20byteHexString \land n\in \mathbb{N} \}$ ein valiedes initiales Wort in der $L(S(G))$ Sprache erzeugt 
    \item Akteure können durch eine Öffentliche Schnittstelle( Webseite ) in die Historie einsehen, sowie das Wort valide manipulieren.
    \item Die Konsensfunktion wird ebenfalls Implementiert.
  \end{itemize}
  \item Es wird keine Dezentrale version Implementiert.
  \item Die Delegationen sowie die Abstimmungen werden direkt Implementiert und können jederzeit beteiligten Akteuren zugeordnet werden. Eine anonyme Lösung, mithilfe einer homomorphen verschlüsselung oder eines zero knowledge proofs wird zwar diskutiert, jedoch weder konzipiert noch implementiert
\end{itemize}

\subsection*{Todos}

\listoftodos[Notes]



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%       Aussicht
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Aussicht}

\subsection{Dezentralisierung}

\begin{itemize}
  \item änderungen der Grammatik berücksichtigen
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      QUELLEN
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage
\section{Quellen}


\bibliography{library}

\bibliographystyle{alpha}

\end{document}

